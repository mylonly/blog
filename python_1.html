<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Python - 独自一人
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="独自一人" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://pic.mylonly.com/2017-05-11-IMG_1164.JPG" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">独自一人</a></h1>
					<p class="subtitle">独自一人,独自Coding...</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">










<a target="_blank" class="github" target="_blank" href="https://github.com/mylonly" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:root@mylonly.com" title="Email">Email</a>

								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-06-24T19:11:42+08:00" itemprop="datePublished">2016/6/24</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14945011027951.html" itemprop="url">
		Python利用Pexpect模拟ssh交互</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<blockquote>
<p><mark>关于Pexpect</mark><br/>
Pexpect 是 Don Libes 的 Expect 语言的一个 Python 实现，是一个用来启动子程序，并使用正则表达式对程序输出做出特定响应，以此实现与其自动交互的 Python 模块。 Pexpect 的使用范围很广，可以用来实现与 ssh、ftp 、telnet 等程序的自动交互；可以用来自动复制软件安装包并在不同机器自动安装；还可以用来实现软件测试中与命令行交互的自动化。</p>
</blockquote>

<h5 id="toc_0">本文利用到的Pexpect的类和方法</h5>

<ol>
<li><p><code>spawn()</code>类:</p>
<pre><code class="language-python">class spawn:
    def __init__(self,command,args=[],timeout=30,maxread=2000,\<br/>
    searchwindowsize=None, logfile=None, cwd=None, env=None)
</code></pre>
<p>spawn是Pexpect模块主要的类，用以实现启动子程序，它有丰富的方法与子程序交互从而实现用户对子程序的控制。它主要使用 pty.fork() 生成子进程，并调用 exec() 系列函数执行 command 参数的内容。</p></li>
<li><p><code>spawn()</code>类中的<code>expect()</code>函数:</p>
<pre><code class="language-python">expect(self, pattern, timeout=-1, searchwindowsize=None)
</code></pre>
<p>在参数中： pattern 可以是正则表达式， pexpect.EOF ， pexpect.TIMEOUT ，或者由这些元素组成的列表。需要注意的是，当 pattern 的类型是一个列表时，且子程序输出结果中不止一个被匹配成功，则匹配返回的结果是缓冲区中最先出现的那个元素，或者是列表中最左边的元素。使用 timeout 可以指定等待结果的超时时间 ，该时间以秒为单位。当超过预订时间时， expect 匹配到pexpect.TIMEOUT。</p></li>
<li><p><code>spawn()</code>类中的<code>before</code>和<code>after</code>属性:</p>
<p>expect 不断从读入缓冲区中匹配目标正则表达式，当匹配结束时 pexpect 的 before 成员中保存了缓冲区中匹配成功处之前的内容， pexpect 的 after 成员保存的是缓冲区中与目标正则表达式相匹配的内容。</p>
<pre><code class="language-python">child = pexpect.spawn(&#39;/bin/ls /&#39;) 
child.expect (pexpect.EOF) <br/>
print child.before
</code></pre>
<p>以上代码就是打印在根目录下面执行ls命令后的输出内容</p></li>
<li><p><code>spawn()</code>类中的send系列函数:</p>
<pre><code class="language-python">send(self, s) 
sendline(self, s=&#39;&#39;) <br/>
sendcontrol(self, char)
</code></pre>
<p>这些方法用来向子程序发送命令，模拟输入命令的行为。 与 send() 不同的是 sendline() 会额外输入一个回车符 ，更加适合用来模拟对子程序进行输入命令的操作。 当需要模拟发送 “Ctrl+c” 的行为时，还可以使用 sendcontrol() 发送控制字符。</p>
<pre><code class="language-python">child.sendcontrol(&#39;c&#39;)
</code></pre></li>
</ol>

<h5 id="toc_1">功能模块分解</h5>

<ol>
<li><p>首先我们需要一个可以单独的session会话，可以由connect函数创建指定host,username和password的会话子进程</p>
<pre><code class="language-text">```Python
PROMPT = [&#39;#&#39;,&#39;$&#39;,&#39;&gt;&#39;,&#39;\$&#39;,&#39;&gt;&gt;&gt;&#39;]<br/>
def createChildSession(host,username,password):<br/>
    command = &#39;ssh &#39;+username+&#39;@&#39;+host<br/>
    child = pexpect.spawn(command)<br/>
    ret = child.expect([pexpect.TIMEOUT,&#39;Are you sure you want to continue connecting&#39;,&#39;[P|p]assword&#39;]+PROMPT)<br/>
    if ret == 0:<br/>
        print(&#39;[-] Error Connecting&#39;)<br/>
        return<br/>
    if ret == 1:<br/>
        child.sendline(&#39;yes&#39;)<br/>
        ret = child.expect([pexpect.TIMEOUT,&#39;[p|P]assword&#39;])<br/>
        if ret == 0:<br/>
            print(&#39;[-] Error Connecting&#39;)<br/>
            return<br/>
        if ret == 1:<br/>
            send_command(password)<br/>
            return<br/>
    if ret == 2:<br/>
        send_command(password)<br/>
        return<br/>
    return child<br/>
```<br/>
利用spawn创建会话之后,利用expect匹配可能存在的返回结果,如果匹配&#39;Are you sure you want to continue connecting&#39; 说明需要确认认证信息，如果直接返回password或者Password`这里利用[p|P]assword正则来匹配`,说明需要输入密码,如果直接是PROMPT中存在的字符，说明直接登录上去了。
</code></pre></li>
<li><p>一个单独的执行命令的函数:</p>
<pre><code class="language-python">def send_command(child,cmd):
    child.sendline(cmd)<br/>
    child.expect(PROMPT)<br/>
    print(child.before)
</code></pre>
<p>一旦通过验证,我们就可以用上面的command函数在ssh会话中发送命令，然后等待命令提示符的出现，最后将命令的执行结果通过child.before打印出来。</p></li>
<li><p>一个包含参数解析的main函数:</p>
<pre><code class="language-python">def main():
    parse = optparse.OptionParser(&#39;Usage %prog -H &lt;host&gt; -u &lt;username&gt; -p &lt;password&gt; -c &lt;command&gt;&#39;)<br/>
    parse.add_option(&#39;-H&#39;,dest=&#39;host&#39;,type=&#39;string&#39;,help=&#39;specify the host&#39;)<br/>
    parse.add_option(&#39;-u&#39;,dest=&#39;username&#39;,type=&#39;string&#39;,help=&#39;specify the username&#39;)<br/>
    parse.add_option(&#39;-p&#39;,dest=&#39;password&#39;,type=&#39;string&#39;,help=&#39;specify the password&#39;)    <br/>
    parse.add_option(&#39;-c&#39;,dest=&#39;command&#39;,type=&#39;string&#39;,help=&#39;specify the command&#39;)<br/>
    (options,args)=parse.parse_args()<br/>
    host = options.host<br/>
    username = options.username<br/>
    password = options.password<br/>
    command = options.command<br/>
    session = createChildSession(host,username,password)<br/>
    send_command(session,command)
</code></pre>
<p>optparse是一个用来给你的代码添加各种命令参数的库，用其解析出输入的host,username,password已经command,然后调用创建session会话，最后利用send_command向此session发送命令</p></li>
</ol>

<pre><code class="language-bash">tianxianggendeiMac:Python-Study Apple$ python ssh.py -H pi.****.com -u root -p ***** -c pwd
</code></pre>

<p>输出:</p>

<pre><code class="language-bash"> pwd
/root
root@raspberrypi:~
</code></pre>

<h5 id="toc_2">完整代码</h5>

<pre><code class="language-python">#!/usr/bin/python
#-*-coding:utf-8-*-
# date:2016-6-21
# author:root
# 利用pexpect模拟ssh登陆

import pexpect
import optparse

PROMPT = [&#39;#&#39;,&#39;$&#39;,&#39;&gt;&#39;,&#39;\$&#39;,&#39;&gt;&gt;&gt;&#39;]

def send_command(child,cmd):
    child.sendline(cmd)
    child.expect(PROMPT)
    print(child.before)

def createChildSession(host,username,password):
    command = &#39;ssh &#39;+username+&#39;@&#39;+host
    child = pexpect.spawn(command)
    ret = child.expect([pexpect.TIMEOUT,&#39;Are you sure you want to continue connecting&#39;,&#39;[P|p]assword&#39;]+PROMPT)
    if ret == 0:
        print(&#39;[-] Error Connecting&#39;)
        return
    if ret == 1:
        child.sendline(&#39;yes&#39;)
        ret = child.expect([pexpect.TIMEOUT,&#39;[p|P]assword&#39;])
        if ret == 0:
            print(&#39;[-] Error Connecting&#39;)
            return
        if ret == 1:
            send_command(password)
            return
    if ret == 2:
        send_command(password)
        return
    return child

def main():
    parse = optparse.OptionParser(&#39;Usage %prog -H &lt;host&gt; -u &lt;username&gt; -p &lt;password&gt; -c &lt;command&gt;&#39;)
    parse.add_option(&#39;-H&#39;,dest=&#39;host&#39;,type=&#39;string&#39;,help=&#39;specify the host&#39;)
    parse.add_option(&#39;-u&#39;,dest=&#39;username&#39;,type=&#39;string&#39;,help=&#39;specify the username&#39;)
    parse.add_option(&#39;-p&#39;,dest=&#39;password&#39;,type=&#39;string&#39;,help=&#39;specify the password&#39;)    
    parse.add_option(&#39;-c&#39;,dest=&#39;command&#39;,type=&#39;string&#39;,help=&#39;specify the command&#39;)

    (options,args)=parse.parse_args()
    host = options.host
    username = options.username
    password = options.password
    command = options.command
    
    session = createChildSession(host,username,password)
    send_command(session,command)

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-05-30T19:12:12+08:00" itemprop="datePublished">2016/5/30</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14945011328774.html" itemprop="url">
		Scrapy模拟登陆知乎</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><img src="https://pic.mylonly.com/2016-06-29_14645998164473.jpg" alt="2016-06-29_14645998164473.jpg"/><br/>
感谢简书作者<code>Andrew_liu</code>提供的思路,虽然知乎改版后，该文章上提供的方法已经失效<a href="http://www.jianshu.com/p/b7f41df6202d">Python爬虫(七)--Scrapy模拟登录<br/>
</a></p>

<p>利用Scrapy提供的cookie中间价很容易做到网页的模拟登陆,下面就来介绍怎么利用这个cookie中间件来登陆知乎。</p>

<h3 id="toc_0">前期分析工作</h3>

<ul>
<li><p>打开<a href="https://www.zhihu.com,%E5%88%A9%E7%94%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84Debug%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%AE%9A%E4%BD%8D%E5%88%B0%E7%99%BB%E9%99%86%E6%A1%86%E6%89%80%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA">https://www.zhihu.com,利用Chrome浏览器的Debug功能，定位到登陆框所在的位置，如下图所示</a><br/>
<img src="https://pic.mylonly.com/2016-06-29_14645980407304.jpg" alt="2016-06-29_14645980407304.jpg"/><br/>
利用scrapy提供的xpath能很方便的获取到这个值(//div[@data-za-module=&quot;SignInForm&quot;]//form//input[@name=&quot;_xsrf&quot;]/@value&#39;)</p></li>
<li><p>选中Debug窗口的Network选项，同时在输完账号密码后点击登陆，获取登陆操作后的post请求，见下图:</p></li>
</ul>

<p><img src="https://pic.mylonly.com/2016-06-29_14645982403637.jpg" alt="2016-06-29_14645982403637.jpg"/><br/>
点击这个链接，确认这个链接就是提交登陆的url<br/>
<img src="https://pic.mylonly.com/2016-06-29_14645983258011.jpg" alt="2016-06-29_14645983258011.jpg"/><br/>
从FormData里面可以看到<a href="https://www.zhihu.com/email/login%E5%B0%B1%E6%98%AF%E7%99%BB%E9%99%86POST%E8%AF%B7%E6%B1%82%E7%9A%84url%EF%BC%8C%E9%9C%80%E8%A6%81%E6%8F%90%E4%BA%A44%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E5%85%B6%E4%B8%AD_xsrf%E5%B0%B1%E6%98%AF%E9%A6%96%E9%A1%B5%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E9%9A%90%E8%97%8F%E8%A1%A8%E5%8D%95%E5%8F%82%E6%95%B0%EF%BC%8Cremember_me%E6%98%AF%E6%98%AF%E5%90%A6%E8%AE%B0%E4%BD%8Fcookie%E7%9A%84%E5%BC%80%E5%85%B3%EF%BC%8Cemail%E5%92%8Cpassword%E5%AF%B9%E5%BA%94%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81">https://www.zhihu.com/email/login就是登陆POST请求的url，需要提交4个参数，其中_xsrf就是首页可以获取到的隐藏表单参数，remember_me是是否记住cookie的开关，email和password对应账号和密码</a></p>

<blockquote>
<p>此处可能有不一样的地方，因为我的知乎账号是email注册的，根据这个url的特征推测别的账号类型可能存在不一样的Url</p>
</blockquote>

<h3 id="toc_1">编写蜘蛛代码</h3>

<p>1.继承CrawlSpider,并重写spider的start_request方法，让spier先访问登录页再去爬取start_urls中的链接，在start_requests方法中，让spider先去访问知乎首页，去获取隐藏的表单项<code>_xsrf</code></p>

<pre><code class="language-python">def start_requests(self):
        return [Request(&quot;https://www.zhihu.com/&quot;,headers = self.headers,meta={&quot;cookiejar&quot;:1},callback=self.post_login)]
</code></pre>

<p>其中header需要自定义，因为知乎对spider做了限制，应该是检测User-Agent，你可以在setting.py中更改spider的默认UserAgent,也可以像我这样自己自定义一个</p>

<pre><code class="language-pythoh">headers = {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;,
    &quot;Accept-Language&quot;: &quot;en-US,en;q=0.8,zh-TW;q=0.6,zh;q=0.4&quot;,
    &quot;Connection&quot;: &quot;keep-alive&quot;,
    &quot;Content-Type&quot;:&quot; application/x-www-form-urlencoded; charset=UTF-8&quot;,
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36&quot;,
    &quot;Referer&quot;: &quot;http://www.zhihu.com&quot;
}
</code></pre>

<p>meta中的cookiejar是Scrapy的Cookie中间件的关键字，具体可参考scrapy文档，这里因为只需要保存一个cookie，所以直接写1(注意:<code>并不是1个cookie才写的1，仅仅是个key，后面通过这个1这个key找到cookiejar中保存的cookie</code>)</p>

<p>2.解析首页内容，获取到_xsrf的值，同时提交登录请求:</p>

<pre><code class="language-python">def post_login(self,response):
        self.log(&quot;preparing login...&quot;)
        xsrf = Selector(response).xpath(&#39;//div[@data-za-module=&quot;SignInForm&quot;]//form//input[@name=&quot;_xsrf&quot;]/@value&#39;).extract()[0]
        self.log(xsrf)
        return FormRequest(&quot;https://www.zhihu.com/login/email&quot;,meta={&#39;cookiejar&#39;:1},
                                          headers = self.headers,
                                          formdata = {
                                             &#39;_xsrf&#39;:xsrf,
                                             &#39;password&#39;:&#39;xgBKQTx7VnVLK9tv&#39;,
                                             &#39;email&#39;:&#39;tianxianggen@gmail.com&#39;,
                                             &#39;remember_me&#39;:&#39;true&#39;,
                                          },
                                          callback = self.after_login,
                                          )
</code></pre>

<ol>
<li>将登录成功后获取到的cookie传递给每一个start_urls中链接的ruquest</li>
</ol>

<pre><code class="language-python">def after_login(self,response):
        for url in self.start_urls:
            yield Request(url,meta={&#39;cookiejar&#39;:1},headers = self.headers)
</code></pre>

<p>4.由于cookiejar中的cookie并不会自动发送给每个链接，因此在urls通过Rule获取到的连接，也是需要我们手动将cookie加上，通过Rule提供的process_request参数重新创建带cookie的Request</p>

<pre><code class="language-pythoh">rules = (
        Rule(SgmlLinkExtractor(allow=(&#39;/question/\d*&#39;)),process_request=&quot;request_question&quot;),
    )
</code></pre>

<p>同时提供request_question函数</p>

<pre><code class="language-python">def request_question(self,request):
        return Request(request.url,meta={&#39;cookiejar&#39;:1},headers = self.headers,callback=self.parse_question)
</code></pre>

<p>5.由于已经有了process_link ,Rule中的callback参数就不再起作用了，而是调用新构造的Request中的callback函数。</p>

<pre><code class="language-python">def parse_question(self,response):
        sel = Selector(response)
        item = zhihuItem()
        item[&#39;qestionTitle&#39;] = sel.xpath(&quot;//div[@id=&#39;zh-question-title&#39;]//h2/text()&quot;).extract_first()
        item[&#39;image_urls&#39;] = sel.xpath(&quot;//img[@class=&#39;origin_image zh-lightbox-thumb lazy&#39;]/@data-original&quot;).extract()
        return item
</code></pre>

<blockquote>
<p>这个parse_question方法仅仅是获取问题名称和问题下面的所有图片链接。</p>
</blockquote>

<h3 id="toc_2">完整代码</h3>

<pre><code class="language-python">import urllib2
import os
import re
import codecs


from scrapy.contrib.spiders import CrawlSpider,Rule
from scrapy.contrib.linkextractors.sgml import SgmlLinkExtractor
from scrapy.selector import Selector
from MySpider.items import zhihuItem
from scrapy.http import Request
from scrapy.http import FormRequest
from scrapy.utils.response import open_in_browser


class zhihuSpider(CrawlSpider):
    name = &quot;zhihu&quot;
    allow_domians = [&quot;zhihu.com&quot;]
    start_urls = [&quot;https://www.zhihu.com/collection/38624707&quot;]
    rules = (
        Rule(SgmlLinkExtractor(allow=(&#39;/question/\d*&#39;)),process_request=&quot;request_question&quot;),
    )
    
    headers = {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;,
    &quot;Accept-Language&quot;: &quot;en-US,en;q=0.8,zh-TW;q=0.6,zh;q=0.4&quot;,
    &quot;Connection&quot;: &quot;keep-alive&quot;,
    &quot;Content-Type&quot;:&quot; application/x-www-form-urlencoded; charset=UTF-8&quot;,
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36&quot;,
    &quot;Referer&quot;: &quot;http://www.zhihu.com&quot;
    }
    
    def start_requests(self):
        return [Request(&quot;https://www.zhihu.com/&quot;,headers = self.headers,meta={&quot;cookiejar&quot;:1},callback=self.post_login)]
        
    def post_login(self,response):
        self.log(&quot;preparing login...&quot;)
        xsrf = Selector(response).xpath(&#39;//div[@data-za-module=&quot;SignInForm&quot;]//form//input[@name=&quot;_xsrf&quot;]/@value&#39;).extract()[0]
        self.log(xsrf)
        return FormRequest(&quot;https://www.zhihu.com/login/email&quot;,meta={&#39;cookiejar&#39;:response.meta[&#39;cookiejar&#39;]},
                                          headers = self.headers,
                                          formdata = {
                                             &#39;_xsrf&#39;:xsrf,
                                             &#39;password&#39;:&#39;差点就忘了删了&#39;,
                                             &#39;email&#39;:&#39;邮箱也不能暴露&#39;,
                                             &#39;remember_me&#39;:&#39;true&#39;,
                                          },
                                          callback = self.after_login,
                                          )
                                                      
    def after_login(self,response):
        for url in self.start_urls:
            yield Request(url,meta={&#39;cookiejar&#39;:1},headers = self.headers)
   
    def request_question(self,request):
        return Request(request.url,meta={&#39;cookiejar&#39;:1},headers = self.headers,callback=self.parse_question)
        
    def parse_question(self,response):
        sel = Selector(response)
        item = zhihuItem()
        item[&#39;qestionTitle&#39;] = sel.xpath(&quot;//div[@id=&#39;zh-question-title&#39;]//h2/text()&quot;).extract_first()
        item[&#39;image_urls&#39;] = sel.xpath(&quot;//img[@class=&#39;origin_image zh-lightbox-thumb lazy&#39;]/@data-original&quot;).extract()
        return item
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-05-11T19:12:34+08:00" itemprop="datePublished">2016/5/11</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14945011548149.html" itemprop="url">
		简单Scrapy爬虫</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>只是个小小的demo，自己测试了下，总共down了20几张图片</p>

<pre><code class="language-python">#coding: utf-8 #############################################################
# File Name: spiders/wallpaper.py
# Author: mylonly
# mail: tianxianggen@gmail.com
#Blog:www.mylonly.com
# Created Time: 2014年09月01日 星期一 14时20分07秒
#########################################################################
#!/usr/bin/python
import urllib2
import os
 
from scrapy.contrib.spiders import CrawlSpider,Rule
from scrapy.contrib.linkextractors.sgml import SgmlLinkExtractor
from scrapy.selector import Selector
from mylonly.items import wallpaperItem
from scrapy.http import Request
 
class wallpaper(CrawlSpider):
    name = &quot;wallpaperSpider&quot;
    allowed_domains = [&#39;sj.zol.com.cn&#39;]
    start_urls = [&#39;http://sj.zol.com.cn/&#39;]
    number = 0
    rules = (
    Rule(SgmlLinkExtractor(allow = (&#39;detail_\d{4}_\d{5}\.html&#39;)),callback =     &#39;parse_image&#39;,follow=True),)
    def parse_image(self,response):
        self.log(&#39;hi,this is an item page! %s&#39; % response.url)
        sel = Selector(response)
        sites = sel.xpath(&quot;//div[@class=&#39;wrapper        mt15&#39;]//dd[@id=&#39;tagfbl&#39;]//a[@target=&#39;_blank&#39;]/@href&quot;).extract()
        for site in sites:
        url = &#39;http://sj.zol.com.cn%s&#39; % (site)
        print &#39;one page:&#39;,url
        return Request(url,callback = self.parse_href)
    def parse_href(self,response):
        print &#39;I am in:&#39;,response.url
        sel = Selector(response)
        src = sel.xpath(&quot;//body//img/@src&quot;).extract()[0]
        self.download(src)
 
    def download(self,url):
        self.number += 1
        savePath = &#39;/mnt/python_image/%d.jpg&#39; % (self.number)
        print &#39;正在下载...&#39;,url
        try:
            u = urllib2.urlopen(url)
            r = u.read()
            downloadFile = open(savePath,&#39;wb&#39;)
            downloadFile.write(r)
            u.close()
            downloadFile.close()
        except:
            print savePath,&#39;can not download.&#39;
 
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-05-11T19:11:56+08:00" itemprop="datePublished">2016/5/11</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14945011166438.html" itemprop="url">
		Scrapy——crawlSpider爬虫</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>Scrapy中的BaseSpider爬虫类只能抓取start_urls中提供的链接，而利用Scrapy提供的crawlSpider类可以很方便的自动解析网页上符合要求的链接，从而达到爬虫自动抓取的功能。<br/>
 <br/>
要利用crawSpider和BaseSpider的区别在于crawSpider提供了一组Rule对象列表，这些Rule对象规定了爬虫抓取链接的行为，Rule规定的链接才会被抓取，交给相应的callback函数去处理。<br/>
  <br/>
在rules中通过SmglLinkExtractor提取希望获取的链接。<br/>
 <br/>
我此次的demo中rule只有一个，如下：</p>

<pre><code class="language-python">allowed_domains = [&#39;sj.zol.com.cn&#39;]
start_urls = [&#39;http://sj.zol.com.cn/bizhi/&#39;]
number = 0
rules = (
            Rule(SgmlLinkExtractor(allow = (&#39;detail_\d{4}_\d{5}\.html&#39;)),callback = &#39;parse_image&#39;,follow=True),
            )
</code></pre>

<p>搜索起始链接下面符合allow中正则表达式的链接，并跟进解析，如果follow = False，则只会解析起始链接中找到的符合要求的链接<br/>
 <br/>
SmglLinkExtractor主要参数：<br/>
 </p>

<ul>
<li>allow：满足括号中“正则表达式”的值会被提取，如果为空，则全部匹配。</li>
<li>deny：与这个正则表达式(或正则表达式列表)不匹配的URL一定不提取。</li>
<li>allow_domains：会被提取的链接的domains。</li>
<li>deny_domains：一定不会被提取链接的domains。</li>
<li>restrict_xpaths：使用xpath表达式，和allow共同作用过滤链接。<br/>
 <br/>
下面的内容就是利用Selector解析获得的response并赋值个item就行了：</li>
</ul>

<pre><code class="language-python">#coding: utf-8 #############################################################
# File Name: spiders/wallpaper.py
# Author: mylonly
# mail: tianxianggen@gmail.com
#Blog:www.mylonly.com
# Created Time: 2014年09月01日 星期一 14时20分07秒
#########################################################################
#!/usr/bin/python
import urllib2
import os
import re
 
from scrapy.contrib.spiders import CrawlSpider,Rule
from scrapy.contrib.linkextractors.sgml import SgmlLinkExtractor
from scrapy.selector import Selector
from mylonly.items import wallpaperItem
from scrapy.http import Request
 
class wallpaper(CrawlSpider):
        name = &quot;wallpaperSpider&quot;
        allowed_domains = [&#39;sj.zol.com.cn&#39;]
        start_urls = [&#39;http://sj.zol.com.cn/bizhi/&#39;]
        number = 0
        rules = (
                        Rule(SgmlLinkExtractor(allow = (&#39;detail_\d{4}_\d{5}\.html&#39;)),callback = &#39;parse_image&#39;,follow=True),
                        )
        def parse_image(self,response):
                self.log(&#39;hi,this is an item page! %s&#39; % response.url)
                sel = Selector(response)
                sites = sel.xpath(&quot;//div[@class=&#39;wrapper mt15&#39;]//dd[@id=&#39;tagfbl&#39;]//a[@target=&#39;_blank&#39;]/@href&quot;).extract()       
                for site in sites:
                        url = &#39;http://sj.zol.com.cn%s&#39; % (site)
                        print &#39;one page:&#39;,url
                        item = wallpaperItem()
                        item[&#39;size&#39;] = re.search(&#39;\d*x\d*&#39;,site).group()
                        item[&#39;altInfo&#39;] = sel.xpath(&quot;//h1//a/text()&quot;).extract()[0]
                        return Request(url,meta = {&#39;item&#39;:item},callback = self.parse_href)
        def parse_href(self,response):
                print &#39;I am in:&#39;,response.url
                item = response.meta[&#39;item&#39;]
                items = []
                sel = Selector(response)
                src = sel.xpath(&quot;//body//img/@src&quot;).extract()[0]
                item[&#39;imgSrc&#39;] = src
                items.append(item)
                return items
                #self.download(src)
        def download(self,url):
                self.number += 1
                savePath = &#39;/mnt/python_image/%d.jpg&#39; % (self.number)
                print &#39;正在下载...&#39;,url
                try:
                        u = urllib2.urlopen(url)
                        r = u.read()
                        downloadFile = open(savePath,&#39;wb&#39;)
                        downloadFile.write(r)
                        u.close()
                        downloadFile.close()
                except:
                        print savePath,&#39;can not download.&#39;
</code></pre>

<p> <br/>
 <br/>
 <br/>
接下来看看我的Item.py的代码：</p>

<pre><code class="language-python">class wallpaperItem(scrapy.Item):
        size = scrapy.Field()
        altInfo = scrapy.Field()
        imgSrc = scrapy.Field()
</code></pre>

<p> <br/>
还有pipilines.py:</p>

<pre><code class="language-python"># -*- coding: utf-8 -*-
 
# Define your item pipelines here
#
# Don&#39;t forget to add your pipeline to the ITEM_PIPELINES setting
# See: http://doc.scrapy.org/en/latest/topics/item-pipeline.html
import MySQLdb
 
 
class MylonlyPipeline(object):
    def process_item(self, item, spider):
        return item
 
class wallpaperPipeline(object):
        def process_item(self,item,spider):
                print &#39;imgSrc:&#39;,item[&#39;imgSrc&#39;]
                db = MySQLdb.connect(&quot;rdsauvva2auvva2.mysql.rds.aliyuncs.com&quot;,&quot;mylonly&quot;,&quot;703003659txg&quot;,&quot;wallpaper&quot;)
                cursor = db.cursor()
                db.set_character_set(&#39;utf8&#39;)
                cursor.execute(&#39;SET NAMES utf8;&#39;)
                cursor.execute(&#39;SET CHARACTER SET utf8;&#39;)
                cursor.execute(&#39;SET character_set_connection=utf8;&#39;)
 
                sql =&quot;INSERT INTO mobile_download(wallpaper_size,wallpaper_info,wallpaper_src)\
                      VALUES(&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;)&quot;%(item[&#39;size&#39;],item[&#39;altInfo&#39;],item[&#39;imgSrc&#39;])
                try:
                        print sql
                        cursor.execute(sql)
                        db.commit()
                except MySQLdb.Error,e:
                        print &quot;Mysql Error %d: %s&quot; % (e.args[0], e.args[1])
                db.close()
                return item
</code></pre>

<p> <br/>
 <br/>
 <br/>
本例中我将传回的items数据存放到了数据库中，如果你不想这样，可以将我注释掉的self.download()取消注释，不反悔items，就可以将找到的所有图片链接全部下载下来，不过要找个大点的地方存储，因为总共有5W多条：<br/>
<img src="https://pic.mylonly.com/2016-06-29_061712481319744.png" alt="2016-06-29_061712481319744.png"/></p>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="python.html">Prev</a>  
	
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>